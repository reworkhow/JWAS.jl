var documenterSearchIndex = {"docs":
[{"location":"manual/block_bayesc/#Block-BayesC-(fast_blocks)","page":"Block BayesC","title":"Block BayesC (fast_blocks)","text":"This page explains how JWAS implements block updates for BayesC marker sampling and how the block path changes speed and memory usage. The block BayesC implementation uses a strategy similar to the blocked update scheme described in the BayesR3 paper. For detailed non-block vs block memory accounting, see Memory Usage. For a real cluster timing benchmark at N=50,000 targeting P=2,000,000 and chain_length=2000, see Benchmark.\n\nBayesR3 paper (Methods): https://www.nature.com/articles/s42003-022-03624-1","category":"section"},{"location":"manual/block_bayesc/#When-This-Path-Is-Used","page":"Block BayesC","title":"When This Path Is Used","text":"Block updates are enabled with:\n\nout = runMCMC(model, phenotypes; fast_blocks=true)\n# or provide a fixed block size\nout = runMCMC(model, phenotypes; fast_blocks=64)\n\nIf fast_blocks=true, JWAS chooses block_size = floor(sqrt(nObs)).\nIn single-trait BayesA/B/C, JWAS calls BayesABC_block!.\nIn multi-trait BayesA/B/C with unconstrained marker covariance (Mi.G.constraint == false), JWAS calls MTBayesABC_block!.\nIf Mi.G.constraint == true, JWAS uses megaBayesABC! (non-block path).\nIn current multi-trait block mode, the update is sampler-I style (trait-wise δ updates from BigPi[d0]/BigPi[d1]) rather than the non-block sampler-I/II dispatcher.\nCurrent implementation note in source: this option is intended for one genotype category.\nIn current implementation, numeric fast_blocks should satisfy block_size < nMarkers (chain-length scaling indexes the second block start).","category":"section"},{"location":"manual/block_bayesc/#Single-Trait-BayesC-Without-Blocks","page":"Block BayesC","title":"Single-Trait BayesC Without Blocks","text":"In the standard BayesC update (BayesABC!), each marker j is updated one-by-one:\n\nCompute conditional posterior terms (rhs, lhs, gHat) from current yCorr.\nCompute marker inclusion probability probDelta1.\nSample δ[j] (include/exclude) and sample/update β[j], α[j].\nImmediately update yCorr using marker column x_j.\n\nSo yCorr is updated every marker.","category":"section"},{"location":"manual/block_bayesc/#Single-Trait-Block-BayesC-in-JWAS","page":"Block BayesC","title":"Single-Trait Block BayesC in JWAS","text":"In the block version (BayesABC_block!), markers are partitioned into blocks.","category":"section"},{"location":"manual/block_bayesc/#Precomputation-(once-before-MCMC)","page":"Block BayesC","title":"Precomputation (once before MCMC)","text":"For each block b, JWAS builds:\n\nX_b (block genotype matrix)\nX_b'R^{-1}X_b (XpRinvX, block Gram matrix)\n\nX_b'R^{-1} is not persisted as a block matrix. Instead, JWAS computes X_b'R^{-1}yCorr on demand into a reusable block workspace vector each outer iteration.","category":"section"},{"location":"manual/block_bayesc/#Update-flow-inside-each-MCMC-outer-iteration","page":"Block BayesC","title":"Update flow inside each MCMC outer iteration","text":"For each block:\n\nBuild block RHS once: XpRinvycorr = X_b'R^{-1} yCorr.\nUpdate markers inside the block using BayesC logic.\nInstead of touching full yCorr each marker, update the block RHS using columns of X_b'R^{-1}X_b.\nAfter finishing the block, update full yCorr once: yCorr += X_b * (α_old_block - α_new_block).","category":"section"},{"location":"manual/block_bayesc/#Important-implementation-detail","page":"Block BayesC","title":"Important implementation detail","text":"In the current JWAS code:\n\ninner repeats are set to nreps = block_size;\nouter chain_length is reduced by approximately block_size.\n\nThis keeps effective marker-update work on a similar scale while moving much of the per-marker work from nObs-length operations to block_size-length operations.","category":"section"},{"location":"manual/block_bayesc/#Detailed-Comparison-with-BayesR3","page":"Block BayesC","title":"Detailed Comparison with BayesR3","text":"Reference paper: BayesR3 (Communications Biology, 2022), DOI: 10.1038/s42003-022-03624-1.\n\nJWAS uses BayesC (not BayesR), but the block linear-algebra strategy closely follows the same blocked Gibbs pattern.","category":"section"},{"location":"manual/block_bayesc/#Step-by-step-correspondence","page":"Block BayesC","title":"Step-by-step correspondence","text":"BayesR3 paper step JWAS block BayesC implementation Status\nPartition markers into blocks fast_blocks builds marker blocks Same strategy\nBuild per-block RHS (rb = Vb'We) block_rhs!(XpRinvycorr, XArray[i], yCorr, Rinv, unit_weights) Same strategy\nWithin-block marker update uses current block RHS BayesC per-marker rhs/lhs/gHat from XpRinvycorr Same strategy\nIn-block RHS correction via block Gram column BLAS.axpy!(..., view(XpRinvX[i],:,j), XpRinvycorr) Same strategy\nUpdate residual once on block exit yCorr += X_b*(α_old_block-α_new_block) Same strategy","category":"section"},{"location":"manual/block_bayesc/#What-is-different","page":"Block BayesC","title":"What is different","text":"Topic BayesR3 paper JWAS block BayesC Practical implication\nMarker prior model BayesR mixture (multiple non-zero normal components plus zero component) BayesC spike-slab style inclusion (δ∈{0,1} for this path) Same acceleration idea, different posterior model\nMarker state sampling Multi-class mixture state Binary include/exclude state Not numerically identical to BayesR\nInner-repeat schedule Uses nominal block size as fixed repeat count across blocks nreps = current block_size Last short block may receive fewer inner repeats\nOuter-loop scheduling Described as a fixed block sweep schedule JWAS also rescales outer chain_length by block size Compare effective updates, not just outer iterations\nScope BayesR algorithm JWAS block path is wired to BayesA/B/C marker samplers, with multi-trait block updates implemented in sampler-I style Strategy reused in a different Bayesian alphabet member","category":"section"},{"location":"manual/block_bayesc/#Scheduling-detail-(explicit)","page":"Block BayesC","title":"Scheduling detail (explicit)","text":"JWAS sets nreps equal to the current block size.\n\nFull blocks: nreps equals the nominal block size.\nFinal short block: nreps is smaller than full blocks.\n\nIn the BayesR3 description, nreps is treated as fixed by the nominal block size for all blocks, including the final short block.\n\nThis difference changes the number of within-block Gibbs sweeps for short blocks, but not the core residual/RHS block-update identity.","category":"section"},{"location":"manual/block_bayesc/#Algorithm-Comparison","page":"Block BayesC","title":"Algorithm Comparison","text":"Aspect Standard BayesC (BayesABC!) Block BayesC (BayesABC_block!) Practical effect\nUpdate unit One marker at a time One block, then markers inside block Better cache locality in block path\nyCorr updates Every marker Once per block Fewer full-length vector updates\nMain per-marker linear algebra size nObs block_size (inside block cache) Lower per-marker arithmetic cost\nExtra precompute Minimal X_b'R^{-1}X_b for all blocks (RHS computed on demand) More startup work\nExtra memory Minimal Stores block Gram matrices (XpRinvX) and block workspaces Higher memory than non-block, lower than older persisted-XRinvArray design\nChain behavior in current implementation Direct chain_length Inner repeats + outer chain scaling Compare runs by effective updates, not only outer iterations","category":"section"},{"location":"manual/block_bayesc/#Computational-Complexity","page":"Block BayesC","title":"Computational Complexity","text":"Use the notation:\n\nN: number of records (nObs)\nP: number of markers (nMarkers)\nb: nominal block size\nB = ceil(P/b): number of blocks\nL: standard (non-block) chain length","category":"section"},{"location":"manual/block_bayesc/#Standard-BayesC-(non-block)","page":"Block BayesC","title":"Standard BayesC (non-block)","text":"Per MCMC iteration: O(PN) (marker-wise dot products and residual updates over N records)\nTotal over L iterations: O(LPN)","category":"section"},{"location":"manual/block_bayesc/#JWAS-block-BayesC-(current-implementation)","page":"Block BayesC","title":"JWAS block BayesC (current implementation)","text":"Let block sizes be s_i with sum_i s_i = P.\n\nPer outer iteration:\n\nBlock RHS construction across all blocks: O(NP)\nIn-block updates: O(sum_i s_i^3) (because nreps = s_i and in-block RHS updates are length-s_i)\nResidual updates on block exit across all blocks: O(NP)\n\nSo per outer iteration:\n\nO(NP + sum_i s_i^3)\nWith near-uniform blocks (s_i ≈ b): O(NP + P b^2)\n\nJWAS rescales outer iterations to approximately m = floor(L/b), so the main total cost is:\n\nO((L/b) * (NP + P b^2)) = O(LP(N/b + b))","category":"section"},{"location":"manual/block_bayesc/#BayesR3-(block-strategy-and-paper-fit)","page":"Block BayesC","title":"BayesR3 (block strategy and paper fit)","text":"BayesR3 uses the same blocked-update strategy family (block RHS, in-block updates using a block Gram matrix, then a block-exit residual update), but it is a BayesR mixture model rather than BayesC. This changes constants (more mixture-state work per marker), not the core block linear-algebra pattern.\n\nOperation-count view (dense blocked implementation):\n\nBayesR3 runs a nominal number of inner cycles n per block, and the paper recommends n be equal to the (nominal) block size b.\nWith n = b, the leading operation-count terms match the same block strategy family as JWAS: total work scales like O(LP(N/b + b)).\n\nPaper runtime fit (Fig. 5):\n\nThe BayesR3 paper reports an empirical timing model where processing time per SNP is proportional to (N + b)/b = N/b + 1.\nThis is a fit to measured runtime for their implementation/hardware and is not a formal asymptotic operation-count derivation. It effectively treats the in-block work (the +b-type term) as a small constant relative to the N/b term in that regime.","category":"section"},{"location":"manual/block_bayesc/#Practical-differences-in-complexity-interpretation","page":"Block BayesC","title":"Practical differences in complexity interpretation","text":"JWAS and BayesR3 share the same blocked-update strategy family, but are not identical in constants/scheduling details.\nJWAS uses nreps = current block_size for each block (including the final short block).\nBayesR3 describes using the nominal block repeat count for all blocks, including the final short block.","category":"section"},{"location":"manual/block_bayesc/#Numerical-example-(N200,000,-P2,000,000)","page":"Block BayesC","title":"Numerical example (N=200,000, P=2,000,000)","text":"Assume fast_blocks=true, so JWAS uses b = floor(sqrt(N)) = 447. Then:\n\nB = ceil(P/b) = ceil(2,000,000/447) = 4,475 blocks\nStandard BayesC total scaling: O(LPN) = O(L * 2,000,000 * 200,000)\nJWAS block BayesC main scaling: O(LP(N/b + b)) = O(L * 2,000,000 * (200,000/447 + 447))\nBayesR3 paper timing fit: runtime per SNP ∝ (N + b)/b, so total runtime ∝ L * 2,000,000 * (200,000/447 + 1)\n\nSo the per-LP coefficients are:\n\nStandard BayesC: 200,000\nJWAS block BayesC operation-count: ~894.4 (from N/b + b)\nBayesR3 paper fit: ~448.4 (from N/b + 1)\n\nThis implies:\n\nJWAS block vs standard: ~224x lower\nBayesR3 paper fit vs standard: ~446x lower\nThe apparent ~2.0x gap between ~894 and ~448 is not an apples-to-apples complexity comparison: it is the difference between an operation-count model (N/b + b) and an empirical runtime fit (N/b + 1).","category":"section"},{"location":"manual/block_bayesc/#Detailed-Resource-Model-(Current-fast_blocks-Path)","page":"Block BayesC","title":"Detailed Resource Model (Current fast_blocks Path)","text":"Use:\n\nN: records\nP: markers\nb: nominal block size\ns_i: size of block i, sum_i s_i = P\nt: bytes per floating-point value (4 for Float32, 8 for Float64)","category":"section"},{"location":"manual/block_bayesc/#Memory-formulas","page":"Block BayesC","title":"Memory formulas","text":"Current block implementation (after removing persistent XRinvArray) stores:\n\ndense X: N*P values\nblock Gram matrices XpRinvX: sum_i s_i^2 values\nmarker summary xpRinvx: P values\noptional xRinvArray extra N*P only for non-unit weights in the non-block marker path\nsmall reusable block workspaces (O(b)) for RHS and local deltas\n\nApproximate totals:\n\nUnit weights:\nMem_block_unit ~= t * (N*P + sum_i s_i^2 + P) + O(b*t)\nNon-unit weights:\nMem_block_nonunit ~= t * (2*N*P + sum_i s_i^2 + P) + O(b*t)","category":"section"},{"location":"manual/block_bayesc/#Runtime-working-set","page":"Block BayesC","title":"Runtime working set","text":"Per block update, active high-volume buffers are:\n\nX_b view (N x s_i; no data copy)\nXpRinvX[i] (s_i x s_i)\nblock RHS workspace (s_i)\nyCorr (N)\n\nSo peak additional block-local workspace is roughly:\n\nO(s_i^2 + s_i + N) values","category":"section"},{"location":"manual/block_bayesc/#I/O-and-precompute-considerations","page":"Block BayesC","title":"I/O and precompute considerations","text":"For in-memory dense X, no out-of-core read is required during MCMC sweeps. The expensive setup term is building XpRinvX:\n\nprecompute cost scales with approximately O(N * sum_i s_i^2) (~O(NPb) under near-uniform blocks)\n\nThis setup can dominate startup time for very large N,P, even when per-iteration sampling is fast.","category":"section"},{"location":"manual/block_bayesc/#Worked-Large-Scale-Example-(N500,000,-P2,000,000)","page":"Block BayesC","title":"Worked Large-Scale Example (N=500,000, P=2,000,000)","text":"Assume fast_blocks=true, so b=floor(sqrt(N))=707.\n\nB = ceil(P/b) = 2,829\nsum_i s_i^2 = 1,413,937,788\n\nMemory-relevant terms:\n\nTerm Float32 Float64\nX ~4.00 TB (3.64 TiB) ~8.00 TB (7.28 TiB)\nXpRinvX ~5.66 GB (5.27 GiB) ~11.31 GB (10.53 GiB)\nxpRinvx ~8.0 MB ~16.0 MB\n\nSo for unit weights, block mode remains dominated by X, with XpRinvX as the main incremental memory term.","category":"section"},{"location":"manual/block_bayesc/#What-To-Watch-Closely","page":"Block BayesC","title":"What To Watch Closely","text":"block_size choice:\ntoo small: less speedup (N/b term remains large)\ntoo large: XpRinvX memory and precompute cost rise (~P*b memory and ~NPb setup trend)\nEffective chain length:\ncurrent implementation rescales outer iterations and uses inner repeats (nreps = block_size)\ncompare runs by effective updates, not only outer-iteration count\nFinal short block behavior:\nlast block uses smaller nreps (equal to its own size), so sweep symmetry differs slightly\nMulti-trait block path specifics:\ncurrent path is sampler-I style for unconstrained covariance mode\nextra temporaries (e.g., trait-wise old-alpha handling) can become noticeable at larger trait counts\nNumerical reproducibility:\nmathematically equivalent refactors (e.g., in-place BLAS updates) can change floating-point roundoff\nexpect tiny non-bitwise differences, especially in Float32\nWeighting mode:\nblock XRinvArray is no longer persisted\nseparate non-unit weighted non-block xRinvArray materialization remains a distinct issue\nScope constraints:\ncurrent source notes this fast block option is intended for one genotype category\nnumeric fast_blocks should keep block_size < nMarkers","category":"section"},{"location":"manual/block_bayesc/#Example:-Speed/Memory-Tradeoff","page":"Block BayesC","title":"Example: Speed/Memory Tradeoff","text":"Assume:\n\nnObs = 5_000\nnMarkers = 50_000\nblock_size = 70 (similar to sqrt(nObs))\nnBlocks = 715\n\nApproximate memory (Float32):\n\nItem Approx size\nGenotype matrix X (nObs x nMarkers) ~953.7 MiB\nExtra XpRinvX in block mode ~13.4 MiB\n\nInterpretation:\n\nBlock mode can be much faster for large nObs, because heavy per-marker operations are shifted to block-level cached operations.\nBlock mode uses more memory than non-block mode, mainly from XpRinvX (plus small block workspaces).\nPractical speedup is typically below theoretical arithmetic speedup due to random branching, allocation overhead, and BLAS/runtime effects.","category":"section"},{"location":"manual/block_bayesc/#Practical-Guidance","page":"Block BayesC","title":"Practical Guidance","text":"Start with fast_blocks=true for large marker sets and enough RAM.\nIf memory is tight, set a smaller numeric block size (e.g., 32 or 64) and benchmark.\nIf speed gain is small, try a few block sizes and choose based on wall time + memory headroom.","category":"section"},{"location":"manual/internals/#Internal-functions","page":"Internals","title":"Internal functions","text":"Documentation for JWAS.jl's internal (private) interface, which are not available to general users. These internal functions are small blocks that public function build on.\n\n<!–-","category":"section"},{"location":"manual/internals/#Index","page":"Internals","title":"Index","text":"Pages = [\"internals.md\"]","category":"section"},{"location":"manual/internals/#Internal-interface","page":"Internals","title":"Internal interface","text":"–>","category":"section"},{"location":"manual/internals/#DataAPI.describe-Tuple{JWAS.MME}","page":"Internals","title":"DataAPI.describe","text":"describe(model::MME)\n\nPrint out model information.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.GWAS-Tuple{Any, Any, Vararg{AbstractString}}","page":"Internals","title":"JWAS.GWAS","text":"GWAS(model,map_file,marker_effects_file...;\n     window_size = \"1 Mb\",sliding_window = false,\n     GWAS = true, threshold = 0.001,\n     genetic_correlation = false,\n     header = true)\n\nrun genomic window-based GWAS\n\nMCMC samples of marker effects are stored in markereffectsfile with delimiter ','.\nmodel is either the model::MME used in analysis or the genotype cavariate matrix M::Array\nmap_file has the (sorted) marker position information with delimiter ','. If the map file is not provided, i.e., map_file=false, a fake map file will be generated with window_size markers in each 1 Mb window, and each 1 Mb window will be tested.\nIf two markereffectsfile are provided, and genetic_correlation = true, genomic correlation for each window is calculated.\nStatistics are computed for nonoverlapping windows of size window_size by default. If sliding_window = true, those for overlapping sliding windows are calculated.\nmap file format:\n\nmarkerID,chromosome,position\nm1,1,16977\nm2,1,434311\nm3,1,1025513\nm4,2,70350\nm5,2,101135\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.GWAS-Tuple{Any}","page":"Internals","title":"JWAS.GWAS","text":"GWAS(marker_effects_file;header=true)\n\nCompute the model frequency for each marker (the probability the marker is included in the model) using samples of marker effects stored in markereffectsfile.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.SSBRrun","page":"Internals","title":"JWAS.SSBRrun","text":"(internal) Incomplete Genomic Data (Single-Step)\n\nreorder in A (pedigree) as ids for genotyped then non-genotyped inds\nimpute genotypes for non-genotyped individuals\nadd ϵ (imputation errors) and J as variables in data for non-genotyped inds\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.add_genotypes","page":"Internals","title":"JWAS.add_genotypes","text":"DEPRECATED!! Please use get_genotypes()\n\nadd_genotypes(mme::MME,M::Union{AbstractString,Array{Float64,2},Array{Float32,2},Array{Any,2},DataFrames.DataFrame},G=false;\n              header=false,rowID=false,separator=',',\n              center=true,G_is_marker_variance=false,df=4)\n\nGet marker informtion from a genotype file or an nxp Matrix M of genotypes (Array or DataFrame), where n is the number of individuals and p is the number of markers. This file/matrix needs to be column-wise sorted by marker positions.\nG is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes)\nIf a text file is provided, the file format should be:\nAnimal,marker1,marker2,marker3,marker4,marker5\nS1,1,0,1,1,1\nD1,2,0,2,2,1\nO1,1,2,0,1,0\nO3,0,0,2,1,1\nIf an nxp Matrix of genotypes (Array or DataFrame) is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nrowID is a vector of individual IDs, e.g.,rowID=[\"a1\",\"b2\",\"c1\"]; if it is omitted, IDs will be set to 1:n\nheader is a header vector such as [\"id\"; \"mrk1\"; \"mrk2\";...;\"mrkp\"]. If omitted, marker names will be set to 1:p\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.add_term-Tuple{Any, AbstractString}","page":"Internals","title":"JWAS.add_term","text":"add to model an extra term: imputation_residual\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.block_rhs!-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractVector, Bool}","page":"Internals","title":"JWAS.block_rhs!","text":"block_rhs!(rhs, Xblock, y, Rinv, unit_weights)\n\nCompute block RHS Xblock' * Diagonal(Rinv) * y in-place without storing Xblock' * Diagonal(Rinv) as a persistent matrix.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.build_model","page":"Internals","title":"JWAS.build_model","text":"build_model(model_equations::AbstractString,R=false; df::AbstractFloat=4.0, estimate_variance=true)\n\nBuild a model from model equations with the residual variance R. In Bayesian analysis, R is the mean for the prior assigned for the residual variance with degree of freedom df, defaulting to 4.0. If R is not provided, a value is calculated from responses (phenotypes).\nBy default, all variabels in modelequations are factors (categorical) and fixed. Set variables to be covariates (continuous) or random using functions `setcovariate()orset_random()`.\nThe argument estimate_variance indicates whether to estimate the residual variance; estimate_variance=true is the default.\n\n#single-trait\nmodel_equations = \"BW = intercept + age + sex\"\nR               = 6.72\nmodels          = build_model(model_equations,R);\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex\n                   CW = intercept + litter\";\nR               = [6.72   24.84\n                   24.84  708.41]\nmodels          = build_model(model_equations,R);\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.center!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Internals","title":"JWAS.center!","text":"This function centers columns of the input matrix X by subtracting their means along each column. The function operates in-place by modifying the original matrix X.\n\nInput:\n- X::AbstractMatrix: a matrix to be centered\n\nOutput:\n- col_means::Vector: a vector of mean values for each column in the original matrix, computed before centering.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.check_marker_memory_guard!-Tuple{}","page":"Internals","title":"JWAS.check_marker_memory_guard!","text":"check_marker_memory_guard!(; mode, ratio, estimated_bytes, total_memory_bytes, context_string)\n\nApply guard policy for estimated marker memory usage.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.decode_marker!-Tuple{AbstractVector, JWAS.Packed2BitBackend, Integer}","page":"Internals","title":"JWAS.decode_marker!","text":"decode_marker!(dest, backend, marker_index)\n\nDecode one marker into dest with centering and missing-value mean-imputation.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.estimate_marker_memory-Tuple{Integer, Integer}","page":"Internals","title":"JWAS.estimate_marker_memory","text":"estimate_marker_memory(nObs, nMarkers;\n                       element_bytes,\n                       has_nonunit_weights=false,\n                       block_starts=false,\n                       storage_mode=:dense)\n\nEstimate major marker-path memory components in bytes.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.format_bytes_human-Tuple{Integer}","page":"Internals","title":"JWAS.format_bytes_human","text":"format_bytes_human(bytes)\n\nFormat byte counts into a compact human-readable string.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.getEBV-Tuple{Any, Any}","page":"Internals","title":"JWAS.getEBV","text":"getEBV(model::MME,traiti)\n\n(internal function) Get breeding values for individuals defined by outputEBV(), defaulting to all genotyped individuals. This function is used inside MCMC functions for one MCMC samples from posterior distributions. e.g., non-NNBayespartial (multi-classs Bayes) : y1=M1α1[1]+M2α2[1]+M3α3[1]                                            y2=M1α1[2]+M2α2[2]+M3α3[2]; NNBayespartial:     y1=M1α1[1]                      y2=M2α2[1]                      y3=M3*α3[1];\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.getMCMCinfo-Tuple{Any}","page":"Internals","title":"JWAS.getMCMCinfo","text":"getMCMCinfo(model::MME)\n\n(internal function) Print out MCMC information.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.getMME-Tuple{JWAS.MME, DataFrames.DataFrame}","page":"Internals","title":"JWAS.getMME","text":"Construct mixed model equations with\n\nincidence matrix: X      ; response        : ySparse; left-hand side  : mmeLhs ; right-hand side : mmeLhs ;\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.get_column_ref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Internals","title":"JWAS.get_column_ref","text":"get_column_ref(X::Vector{T})\n\nTo obtain a vector of views (alias/pointer) for each column of the input matrix WITHOUT COPYING the underlying data. \ninput:  a matrix X\noutput: a vector containing views of each column of the input matrix X\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.get_genotypes","page":"Internals","title":"JWAS.get_genotypes","text":"get_genotypes(file::Union{AbstractString,Array{Float64,2},Array{Float32,2},Array{Int64,2}, Array{Int32,2}, Array{Any,2}, DataFrames.DataFrame}, G = false;\n              ## method:\n              method = \"BayesC\",Pi = 0.0,estimatePi = true, \n              ## variance:\n              G_is_marker_variance = false, df = 4.0,\n              estimate_variance=true, estimate_scale=false,\n              constraint = false, #for multi-trait only, constraint=true means no genetic covariance among traits\n              ## format:\n              separator=',',header=true,\n              ## quality control:\n              quality_control=true, MAF = 0.01, missing_value = 9.0,\n              ## others:\n              center=true,starting_value=false,\n              storage=:dense)\n\nGet marker informtion from a genotype file/matrix. This file needs to be column-wise sorted by marker positions.\nIf a text file is provided, the file format should be:\n\nAnimal,marker1,marker2,marker3,marker4,marker5\nS1,1,0,1,1,1\nD1,2,0,2,2,1\nO1,1,2,0,1,0\nO3,0,0,2,1,1\n\nIf a DataFrame is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nThe first column in the DataFrame should be individual IDs\nThe marker IDs can be provided as the header of the DataFrame. If omitted, marker IDs will be set to 1,2,3...\nIf an nxp Matrix of genotypes (Array) is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nIndividual IDs will be set to 1:n; \nMarker IDs will be set to 1:p\nIf quality_control=true, defaulting to true,\nMissing genotypes should be denoted as 9, and will be replaced by column means. Users can also impute missing genotypes before the analysis.\nMinor allele frequency MAF threshold, defaulting to 0.01, is uesd, and fixed loci are removed.\nG is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nAvailable methods include \"conventional (no markers)\", \"RR-BLUP\", \"BayesA\", \"BayesB\", \"BayesC\", \"Bayesian Lasso\", and \"GBLUP\".\nIn Bayesian variable selection methods, Pi for single-trait analyses is a number; Pi for multi-trait analyses is a dictionary such as Pi=Dict([1.0; 1.0]=>0.7,[1.0; 0.0]=>0.1,[0.0; 1.0]=>0.1,[0.0; 0.0]=>0.1), defaulting to all markers have effects (Pi = 0.0) in single-trait analysis and all markers have effects on all traits (Pi=Dict([1.0; 1.0]=>1.0,[0.0; 0.0]=>0.0)) in multi-trait analysis. Pi is estimated if estimatePi = true, , defaulting to false.\nScale parameter for prior of marker effect variance is estimated if estimate_scale = true, defaulting to false.\nstorage=:dense (default) keeps the existing in-memory dense loading behavior. storage=:stream loads an opt-in packed backend prepared by prepare_streaming_genotypes.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.is_unit_weights-Tuple{AbstractVector}","page":"Internals","title":"JWAS.is_unit_weights","text":"is_unit_weights(Rinv)\n\nReturn true if all residual weights are exactly one.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.load_streaming_backend-Tuple{AbstractString}","page":"Internals","title":"JWAS.load_streaming_backend","text":"load_streaming_backend(path::AbstractString)\n\nLoad a packed genotype backend from a prefix (or .jgb2 / .meta path).\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.make_incidence_matrices-Tuple{Any, Any, Any}","page":"Internals","title":"JWAS.make_incidence_matrices","text":"make_incidence_matrices(mme,df_whole,train_index)\n\n(internal function) Make incidence matrices for effects involved in\n\ncalculation of EBV except marker covariates.\n\nBoth incidence matrices for non-missing observations (used in mixed model equations)\n\nand individuals of interest (output IDs) are obtained.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.mkDict-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Internals","title":"JWAS.mkDict","text":"mkDict(a::Vector{T}) where T <: Any\n\nGet column index in the incidence matrix for each level of a factor (categorical variable) \ninput:  a=[\"a1\",\"a4\",\"a1\",\"a2\"] \noutput: d=Dict(\"a2\" => 3, \"a1\" => 1, \"a4\" => 2), level_names=[\"a1\",\"a4\",\"a2\"]\n\nnote: enumerate(level_names) gives a list of tuples (index, element), reverse() to reverse (index,element) to (element,index)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.mkmat_incidence_factor-Tuple{Vector, Vector}","page":"Internals","title":"JWAS.mkmat_incidence_factor","text":"mkmatincidencefactor(yID::Vector, uID::Vector)     create an incidence matrix Z to reorder uID to yID by yID = ZuID.     input:          - yID: a vector containing the desired order of IDs         - uID: a vector containing the original order of IDs     output:          - Z: a sparse matrix representing the incidence relationship between yID and uID (yID = ZuID)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.outputEBV-Tuple{Any, Any}","page":"Internals","title":"JWAS.outputEBV","text":"outputEBV(model,IDs::Array)\n\nOutput estimated breeding values and prediction error variances for IDs.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.outputMCMCsamples-Tuple{JWAS.MME, Vararg{AbstractString}}","page":"Internals","title":"JWAS.outputMCMCsamples","text":"outputMCMCsamples(mme::MME,trmStrs::AbstractString...)\n\nGet MCMC samples for specific location parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.output_MCMC_samples","page":"Internals","title":"JWAS.output_MCMC_samples","text":"output_MCMC_samples(mme,vRes,G0,outfile=false)\n\n(internal function) Save MCMC samples every outputsamplesfrequency iterations to the text file.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.output_MCMC_samples_setup","page":"Internals","title":"JWAS.output_MCMC_samples_setup","text":"output_MCMC_samples_setup(mme,nIter,output_samples_frequency,file_name=\"MCMC_samples\")\n\n(internal function) Set up text files to save MCMC samples.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.output_location_parameters_samples-Tuple{JWAS.MME, Any, Any}","page":"Internals","title":"JWAS.output_location_parameters_samples","text":"output_location_parameters_samples(mme::MME,sol,outfile)\n\n(internal function) Save MCMC samples for location parameers\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.prediction_setup-Tuple{Any}","page":"Internals","title":"JWAS.prediction_setup","text":"prediction_setup(mme::MME)\n\n(internal function) Create incidence matrices for individuals of interest based on a usere-defined\n\nprediction equation, defaulting to genetic values including effects defined with genomic and pedigre information. For now, genomic data is always included.\n\nJ and ϵ are always included in single-step analysis (added in SSBR.jl)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.prepare_streaming_genotypes-Tuple{AbstractString}","page":"Internals","title":"JWAS.prepare_streaming_genotypes","text":"prepare_streaming_genotypes(file::AbstractString;\n                            output_prefix=nothing,\n                            separator=',',\n                            header=true,\n                            missing_value=9.0,\n                            quality_control=true,\n                            MAF=0.01,\n                            center=true,\n                            conversion_mode=:lowmem,\n                            auto_dense_max_bytes=2^30,\n                            tmpdir=nothing,\n                            cleanup_temp=true,\n                            disk_guard_ratio=0.9)\n\nConvert a dense text genotype file to a marker-major 2-bit packed backend.\n\nConversion backend selection:\n\nconversion_mode=:lowmem uses out-of-core staged conversion (disk-backed).\nconversion_mode=:dense uses in-memory conversion.\nconversion_mode=:auto chooses between the two based on auto_dense_max_bytes.\n\nLow-memory conversion options:\n\ntmpdir: optional location for temporary conversion files.\ncleanup_temp: remove temporary files after successful conversion.\ndisk_guard_ratio: fail fast when estimated required bytes exceed disk_guard_ratio * available_bytes.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.runMCMC-Tuple{JWAS.MME, Any}","page":"Internals","title":"JWAS.runMCMC","text":"runMCMC(model::MME,df::DataFrame;\n        #Data\n        heterogeneous_residuals           = false,\n        #MCMC\n        chain_length::Integer             = 100,\n        starting_value                    = false,\n        burnin::Integer                   = 0,\n        output_samples_frequency::Integer = chain_length>1000 ? div(chain_length,1000) : 1,\n        update_priors_frequency::Integer  = 0,\n        #Methods\n        single_step_analysis            = false, #parameters for single-step analysis\n        pedigree                        = false, #parameters for single-step analysis\n        fitting_J_vector                = true,  #parameters for single-step analysis\n        categorical_trait               = false,\n        censored_trait                  = false,\n        causal_structure                = false,\n        mega_trait                      = false,\n        missing_phenotypes              = true,\n        constraint                      = false,\n        #Genomic Prediction\n        outputEBV                       = true,\n        output_heritability             = true,\n        prediction_equation             = false,\n        #MISC\n        seed                            = false,\n        printout_model_info             = true,\n        printout_frequency              = chain_length+1,\n        big_memory                      = false,\n        double_precision                = false,\n        fast_blocks                     = false,\n        memory_guard                    = :error,\n        memory_guard_ratio              = 0.80,\n        ##MCMC samples (defaut to marker effects and hyperparametes (variance components))\n        output_folder                     = \"results\",\n        output_samples_for_all_parameters = false,\n        ##for deprecated JWAS\n        methods                         = \"conventional (no markers)\",\n        Pi                              = 0.0,\n        estimatePi                      = false)\n\nRun MCMC for Bayesian Linear Mixed Models with or without estimation of variance components.\n\nMarkov chain Monte Carlo\nThe first burnin iterations are discarded at the beginning of a MCMC chain of length chain_length.\nSave MCMC samples every output_samples_frequency iterations, defaulting to chain_length/1000, to a folder output_folder, defaulting to results. MCMC samples for hyperparametes (variance componets) and marker effects are saved by default. MCMC samples for location parametes can be saved using function output_MCMC_samples(). Note that saving MCMC samples too frequently slows down the computation.\nThe starting_value can be provided as a vector for all location parameteres and marker effects, defaulting to 0.0s. The order of starting values for location parameters and marker effects should be the order of location parameters in the Mixed Model Equation for all traits (This can be obtained by getNames(model)) and then markers for all traits (all markers for trait 1 then all markers for trait 2...).\nMiscellaneous Options\nPriors are updated every update_priors_frequency iterations, defaulting to 0.\nMethods\nSingle step analysis is allowed if single_step_analysis = true and pedigree is provided.\nMiscellaneous Options\nMissing phenotypes are allowed in multi-trait analysis with missing_phenotypes=true, defaulting to true.\nCatogorical Traits are allowed if categorical_trait=true, defaulting to false. Phenotypes should be coded as 1,2,3...\nCensored traits are allowed if the upper bounds are provided in censored_trait as an array, and lower bounds are provided as phenotypes.\nIf constraint=true, defaulting to false, constrain residual covariances between traits to be zeros.\nIf causal_structure is provided, e.g., causal_structure = [0.0 0.0 0.0;1.0 0.0 0.0;1.0 0.0 0.0] for trait 1 -> trait 2 and trait 1 -> trait 3 (column index affacts row index, and a lower triangular matrix is required), phenotypic causal networks will be incorporated using structure equation models.\nGenomic Prediction\nPredicted values for individuals of interest can be obtained based on a user-defined prediction equation prediction_equation, e.g., \"y1:animal + y1:age\".\nFor now, genomic data is always included. Genetic values including effects defined with genotype and pedigree information are returned if prediction_equation= false, defaulting to false.\nIndividual estimted genetic values and prediction error variances (PEVs) are returned if outputEBV=true, defaulting to true. Heritability and genetic\nvariances are returned if output_heritability=true, defaulting to true. Note that estimation of heritability is computaionally intensive.\nMiscellaneous Options\nPrint out the model information in REPL if printout_model_info=true; print out the monte carlo mean in REPL with printout_frequency, defaulting to false.\nIf seed, defaulting to false, is provided, a reproducible sequence of numbers will be generated for random number generation.\nIf big_memory=true, defaulting to false, a machine with  lots of memory is assumed which may speed up the analysis.\nmemory_guard controls the marker-memory precheck before MCMC (:error, :warn, :off; default :error).\nmemory_guard_ratio sets the allowed fraction of Sys.total_memory() for the precheck (default 0.80).\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.set_covariate-Tuple{JWAS.MME, Vararg{AbstractString}}","page":"Internals","title":"JWAS.set_covariate","text":"set_covariate(model::MME,variables::AbstractString...)\n\nset variables as covariates; model is the output of function build_model().\n\n#After running build_model, variabels age and year can be set to be covariates as\nset_covariate(model,\"age\",\"year\")\n#or\nset_covariate(model,\"age year\")\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.set_random","page":"Internals","title":"JWAS.set_random","text":"set_random(mme::MME,randomStr::AbstractString,ped::Pedigree, G;df=4)\n\nset variables as random polygenic effects with pedigree information ped. and variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\n\n#single-trait (example 1)\nmodel_equation  = \"y = intercept + age + animal\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = 1.6\nset_random(model,\"animal\", ped, G)\n\n#single-trait (example 2)\nmodel_equation  = \"y = intercept + age + animal + animal*age\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = [1.6   0.2\n                   0.2  1.0]\nset_random(model,\"animal animal*age\", ped,G)\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex + animal\n                   CW = intercept + age + sex + animal\"\nmodel           = build_model(model_equations,R);\nped             = get_pedigree(pedfile);\nG               = [6.72   2.84\n                   2.84  8.41]\nset_random(model,\"animal\",ped,G)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.set_random-2","page":"Internals","title":"JWAS.set_random","text":"set_random(mme::MME,randomStr::AbstractString,G;Vinv=0,names=[],df=4)\n\nset variables as random effects, defaulting to i.i.d effects, with variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nthe random effects are assumed to be i.i.d by default and it can be defined with any (inverse of) covariance structure Vinv with its index (row names) provided by names.\n\n#single-trait (i.i.d randome effects)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nG               = 0.6\nset_random(model,\"litter\",G)\n\n#multi-trait (i.i.d randome effects)\nmodel_equations = \"BW = intercept + litter + sex\n                   CW = intercept + litter + sex\"\nmodel           = build_model(model_equations,R);\nG               = [3.72  1.84\n                   1.84  3.41]\nset_random(model,\"litter\",G)\n\n#single-trait (randome effects with specific covariance structures)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nV               = [1.0  0.5 0.25\n                   0.5  1.0 0.5\n                   0.25 0.5 1.0]\nG               = 0.6\nset_random(model,\"litter\",G,Vinv=inv(V),names=[a1;a2;a3])\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.solve-Tuple{JWAS.MME, DataFrames.DataFrame}","page":"Internals","title":"JWAS.solve","text":"solve(mme::MME,df::DataFrame;solver=\"default\",printout_frequency=100,tolerance = 0.000001,maxiter = 5000)\n\nSolve the mixed model equations (no marker information) without estimating variance components.\n\nAvailable solvers include default, Jacobi, Gauss-Seidel, and Gibbs sampler.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.streaming_mul_alpha!-Tuple{AbstractVector, JWAS.Packed2BitBackend, AbstractVector}","page":"Internals","title":"JWAS.streaming_mul_alpha!","text":"streaming_mul_alpha!(out, backend, α)\n\nCompute out = X*α from a streaming backend without materializing dense X.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.transubstrarr-Tuple{Any}","page":"Internals","title":"JWAS.transubstrarr","text":"transubstrarr(vec)\n\n(internal function) Transpose a column vector of strings (vec' doesn't work here)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.Packed2BitBackend","page":"Internals","title":"JWAS.Packed2BitBackend","text":"Packed2BitBackend\n\nStreaming backend for marker-major 2-bit packed genotypes used by storage=:stream in get_genotypes.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#JWAS.PedModule.get_info-Tuple{JWAS.PedModule.Pedigree}","page":"Internals","title":"JWAS.PedModule.get_info","text":"get_info(pedigree::Pedigree;Ai=false)\n\nPrint summary informtion from a pedigree object including number of individulas, sires. dams and founders. Return individual IDs, inverse of numerator relationship matrix, and inbreeding coefficients if Ai=true.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.PedModule.get_pedigree-Tuple{Union{AbstractString, DataFrames.DataFrame}}","page":"Internals","title":"JWAS.PedModule.get_pedigree","text":"get_pedigree(pedfile::AbstractString;header=false,separator=',',missingstrings=[\"0\"])\n\nGet pedigree informtion from a pedigree file with header (defaulting to false) , separator (defaulting to ,) and missing values (defaulting to [\"0\"])\nPedigree file format:\n\na,0,0\nc,a,b\nd,a,c\n\n\n\n\n\n","category":"method"},{"location":"manual/streaming_genotype_backend/#Streaming-Genotype-Backend-(BayesC-MVP)","page":"Streaming Genotype Backend (BayesC MVP)","title":"Streaming Genotype Backend (BayesC MVP)","text":"This page documents the new opt-in streaming genotype backend for large-data original BayesC in JWAS.","category":"section"},{"location":"manual/streaming_genotype_backend/#Status-and-Design","page":"Streaming Genotype Backend (BayesC MVP)","title":"Status and Design","text":"Dense loading remains the default and primary path.\nget_genotypes(...; storage=:dense) (default)\nExisting dense workflows are unchanged.\nStreaming loading is additive and opt-in.\nget_genotypes(...; storage=:stream)\nCurrent status: experimental MVP for original BayesC.","category":"section"},{"location":"manual/streaming_genotype_backend/#Supported-Scope-(MVP)","page":"Streaming Genotype Backend (BayesC MVP)","title":"Supported Scope (MVP)","text":"Single-trait analysis only\nMethod: BayesC only\nfast_blocks=false only\nUnit residual weights only\ndouble_precision=false only\nComplete genomic data only (no single-step)\nExact genotype/phenotype ID match and order required\noutputEBV and output_heritability are disabled in MVP streaming mode","category":"section"},{"location":"manual/streaming_genotype_backend/#Public-API","page":"Streaming Genotype Backend (BayesC MVP)","title":"Public API","text":"","category":"section"},{"location":"manual/streaming_genotype_backend/#prepare_streaming_genotypes(...)","page":"Streaming Genotype Backend (BayesC MVP)","title":"prepare_streaming_genotypes(...)","text":"One-time converter from text genotype file to packed marker-major 2-bit files.\n\nprefix = prepare_streaming_genotypes(\n    \"genotypes.csv\";\n    output_prefix = \"genotypes_stream\",\n    separator = ',',\n    header = true,\n    missing_value = 9.0,\n    quality_control = true,\n    MAF = 0.01,\n    center = true,\n    conversion_mode = :lowmem,   # :lowmem | :dense | :auto\n    auto_dense_max_bytes = 2^30, # used only when conversion_mode=:auto\n    tmpdir = nothing,          # optional temp workspace for conversion spool\n    cleanup_temp = true,       # remove temporary conversion files after success\n    disk_guard_ratio = 0.9,    # fail fast if required bytes exceed ratio * free bytes\n)\n\nOutput artifacts with the chosen prefix:\n\nprefix.jgb2: packed genotype payload (2-bit marker-major)\nprefix.meta: metadata manifest\nprefix.obsid.txt: individual IDs\nprefix.markerid.txt: marker IDs (after QC)\nprefix.mean.f32: per-marker means\nprefix.xpRinvx.f32: per-marker x'x for unit-weight BayesC path\nprefix.afreq.f32: per-marker allele frequencies\n\nConversion notes:\n\nconversion_mode=:lowmem keeps conversion out-of-core (default).\nconversion_mode=:dense uses an in-memory dense conversion path (faster for small files, not RAM-safe for large files).\nconversion_mode=:auto chooses :dense when estimated dense bytes (N*P*4) fit under auto_dense_max_bytes; otherwise uses :lowmem.\nIn low-memory mode, conversion performs a staged write path with temporary row-major spool + transpose.\nTemporary disk can approach one extra packed payload in low-memory mode; for very large N, P, place tmpdir on a high-capacity filesystem.","category":"section"},{"location":"manual/streaming_genotype_backend/#How-to-use-conversion_mode","page":"Streaming Genotype Backend (BayesC MVP)","title":"How to use conversion_mode","text":"Use one of these patterns:\n\n# 1) Large files (safest): always low-memory conversion\nprefix = prepare_streaming_genotypes(\"genotypes.csv\";\n                                     conversion_mode=:lowmem,\n                                     tmpdir=\"/scratch/jwas_tmp\")\n\n# 2) Small files (fast path): force dense in-memory conversion\nprefix = prepare_streaming_genotypes(\"genotypes.csv\";\n                                     conversion_mode=:dense)\n\n# 3) Hybrid default: auto-select dense for small jobs, lowmem otherwise\nprefix = prepare_streaming_genotypes(\"genotypes.csv\";\n                                     conversion_mode=:auto,\n                                     auto_dense_max_bytes=2^30) # 1 GiB threshold\n\nPractical rule: start with conversion_mode=:auto; use :lowmem explicitly for very large jobs or constrained RAM environments.","category":"section"},{"location":"manual/streaming_genotype_backend/#get_genotypes(...;-storage:stream)","page":"Streaming Genotype Backend (BayesC MVP)","title":"get_genotypes(...; storage=:stream)","text":"Load packed genotype backend without materializing dense N x P genotype matrix.\n\ngeno = get_genotypes(\n    prefix,            # prefix or .meta/.jgb2 path\n    1.0;\n    method = \"BayesC\",\n    estimatePi = true,\n    storage = :stream,\n)\n\nDense behavior is unchanged:\n\ngeno = get_genotypes(\"genotypes.csv\", 1.0; method=\"BayesC\")  # storage=:dense default","category":"section"},{"location":"manual/streaming_genotype_backend/#End-to-End-Example","page":"Streaming Genotype Backend (BayesC MVP)","title":"End-to-End Example","text":"using JWAS, CSV, DataFrames\n\nphenotypes = CSV.read(\"phenotypes.csv\", DataFrame)\n\n# one-time conversion\nprefix = prepare_streaming_genotypes(\"genotypes.csv\";\n                                     separator=',',\n                                     header=true,\n                                     quality_control=true,\n                                     center=true)\n\n# streaming load\nglobal geno = get_genotypes(prefix, 1.0;\n                            method=\"BayesC\",\n                            estimatePi=true,\n                            storage=:stream)\n\nmodel = build_model(\"trait1 = intercept + geno\", 1.0)\n\nout = runMCMC(model, phenotypes;\n              chain_length=500,\n              burnin=100,\n              output_samples_frequency=50,\n              output_folder=\"results_stream\",\n              outputEBV=false,\n              output_heritability=false,\n              seed=314,\n              memory_guard=:off)","category":"section"},{"location":"manual/streaming_genotype_backend/#Benchmark-Snapshot","page":"Streaming Genotype Backend (BayesC MVP)","title":"Benchmark Snapshot","text":"All numbers below were measured on:\n\nJulia 1.11.7\nApple M1 (8 CPU threads available)\nmacOS arm64","category":"section"},{"location":"manual/streaming_genotype_backend/#1)-Correctness:-simulated_omics-dense-vs-stream","page":"Streaming Genotype Backend (BayesC MVP)","title":"1) Correctness: simulated_omics dense vs stream","text":"Dataset:\n\n/src/4.Datasets/data/simulated_omics\n3534 individuals\n1000 SNPs (927 markers after QC)\n\nSame seed/settings, single-trait BayesC:\n\nMetric Value\nMarker effects correlation 0.999999999978\nMarker max abs diff 1.10e-6\nMarker mean abs diff 1.65e-7\nResidual variance abs diff 4.29e-7\n\nInterpretation:\n\nStreaming and dense are numerically equivalent up to floating-point noise.","category":"section"},{"location":"manual/streaming_genotype_backend/#2)-Large-synthetic-benchmark-(N10,000,-P5,000)","page":"Streaming Genotype Backend (BayesC MVP)","title":"2) Large synthetic benchmark (N=10,000, P=5,000)","text":"Synthetic CSV genotype file size: ~100 MB.\n\nrunMCMC benchmark (chain_length=25, burnin=5):\n\nMode Real Time Max RSS Peak footprint\nDense (load + run) 24.19s 1.396 GB 1.352 GB\nStream run (after prepare) 20.70s 0.931 GB 0.727 GB\nStream prepare (one-time) 11.99s 1.367 GB 1.144 GB\n\nInterpretation:\n\nStreaming reduced run-time memory significantly in this benchmark.\nConversion has one-time cost and memory use.\nAbsolute times are hardware- and IO-dependent.","category":"section"},{"location":"manual/streaming_genotype_backend/#2b)-Conversion-phase-benchmark-(N10,000,-P5,000)","page":"Streaming Genotype Backend (BayesC MVP)","title":"2b) Conversion-phase benchmark (N=10,000, P=5,000)","text":"Measured with /usr/bin/time -l:\n\nStep Real Time Max RSS\nprepare_streaming_genotypes ~11.8s ~1.14 GB\n\nBackend sizes:\n\nArtifact Size\npacked payload (.jgb2) ~12.5 MB\ntemporary row-major spool (during conversion) ~12.5 MB\n\nInterpretation:\n\nConverter RAM stays bounded for this size and no dense matrix is materialized.\nConversion needs temporary disk in addition to final payload.","category":"section"},{"location":"manual/streaming_genotype_backend/#3)-Target-scale-feasibility-estimator-(N500,000,-P2,000,000)","page":"Streaming Genotype Backend (BayesC MVP)","title":"3) Target-scale feasibility estimator (N=500,000, P=2,000,000)","text":"Using estimate_marker_memory(...):\n\nPath Estimated marker-path memory\nDense (storage=:dense, Float32) 3.64 TiB\nStream (storage=:stream, Float32) 17.29 MiB\n\nInterpretation:\n\nDense original BayesC is generally infeasible at this scale on normal nodes.\nStreaming is designed to keep marker working memory near O(N+P).","category":"section"},{"location":"manual/streaming_genotype_backend/#Notes","page":"Streaming Genotype Backend (BayesC MVP)","title":"Notes","text":"Streaming support for non-unit weights and fast_blocks is planned as follow-up work.\nFor algorithmic memory/speed derivations, see Handling Large Genotype Data Without Loading the Full Matrix into Memory.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Handling-Large-Genotype-Data-Without-Loading-the-Full-Matrix-into-Memory","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","text":"This page summarizes scalability limits and representation options for the standard original BayesC path (fast_blocks=false), with focus on very large datasets such as N=500,000 individuals and P=2,000,000 markers.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Scope","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Scope","text":"Model path: standard BayesC, non-block marker updates.\nObjective: understand memory and speed constraints, and compare storage approaches.\nThis page does not change BayesC posterior equations; it compares data representation and runtime behavior.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Current-JWAS-Status","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Current JWAS Status","text":"Dense loading remains the default and primary path:\nget_genotypes(...; storage=:dense) (default)\nExisting dense workflows are unchanged.\nStreaming loading is additive and opt-in:\nget_genotypes(...; storage=:stream)\nStatus: experimental MVP for large-data BayesC.\nStreaming conversion is out-of-core:\nprepare_streaming_genotypes(...) no longer materializes dense N x P in RAM.\nConversion uses temporary disk plus final packed output (set tmpdir for placement).","category":"section"},{"location":"manual/large_genotype_data_streaming/#Streaming-MVP-workflow","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Streaming MVP workflow","text":"# 1) one-time conversion to packed backend\nprefix = prepare_streaming_genotypes(\\\"genotypes.csv\\\";\n                                     separator=',',\n                                     header=true,\n                                     quality_control=true,\n                                     center=true,\n                                     conversion_mode=:lowmem,\n                                     auto_dense_max_bytes=2^30,\n                                     tmpdir=nothing,\n                                     cleanup_temp=true,\n                                     disk_guard_ratio=0.9)\n\n# 2) load packed backend (no dense N x P matrix in memory)\ngeno = get_genotypes(prefix, 1.0;\n                     method=\\\"BayesC\\\",\n                     storage=:stream)","category":"section"},{"location":"manual/large_genotype_data_streaming/#Streaming-MVP-constraints","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Streaming MVP constraints","text":"single-trait only\nmethod = BayesC only\nfast_blocks=false only\nunit residual weights only\ndouble_precision=false only\ncomplete genomic data only (no single-step)\nexact genotype/phenotype ID match and order required\noutputEBV/output_heritability are disabled in MVP streaming mode","category":"section"},{"location":"manual/large_genotype_data_streaming/#Notation","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Notation","text":"N: number of records (nObs)\nP: number of markers (nMarkers)\nt: bytes per stored value (4 for Float32, 8 for Float64)\nL: chain length (effective non-block iterations)\nc: number of markers decoded/loaded per chunk in an out-of-core path\nB_io: effective sustained storage throughput (GB/s)","category":"section"},{"location":"manual/large_genotype_data_streaming/#Baseline-Complexity-(Original-BayesC)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Baseline Complexity (Original BayesC)","text":"For single-trait original BayesC, each MCMC iteration updates markers one-by-one. The dominant per-iteration cost scales as:\n\nO(NP)\n\nTotal over L iterations:\n\nO(LNP)\n\nAt very large N and P, runtime is dominated by repeated full marker sweeps.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Rough-operation-count","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Rough operation count","text":"For each marker update in the single-trait loop:\n\none dot(x_j, yCorr) term (~2N floating-point ops),\none residual update yCorr += (old-new)*x_j (~2N ops),\nsmall O(1) scalar work.\n\nA practical back-of-the-envelope is:\n\nper iteration: ~4NP flops\ntotal: ~4LNP flops\n\nFor N=500,000, P=2,000,000:\n\n~4e12 flops per iteration (before overhead/branching/cache effects)","category":"section"},{"location":"manual/large_genotype_data_streaming/#Baseline-Memory-(Original-BayesC)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Baseline Memory (Original BayesC)","text":"Main memory terms for one genotype category:\n\nDense genotype matrix X: N x P\nxpRinvx: length P\nxRinvArray:\nunit weights: aliases xArray (no extra N x P data copy)\nnon-unit weights: extra N x P copy\n\nApproximate totals:\n\nUnit weights: Mem_nonblock_unit ~= t * (N*P + P)\nNon-unit weights: Mem_nonblock_nonunit ~= t * (2*N*P + P)\n\nIn practice, N*P dominates.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Worked-Example-(N500,000,-P2,000,000)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Worked Example (N=500,000, P=2,000,000)","text":"N*P = 1,000,000,000,000\n2-bit packed genotype payload size (for comparison): N*P/4 = 250,000,000,000 bytes","category":"section"},{"location":"manual/large_genotype_data_streaming/#Memory-totals-for-original-BayesC","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Memory totals for original BayesC","text":"Case Float32 Float64\nUnit weights ~4.00 TB (3.64 TiB) ~8.00 TB (7.28 TiB)\nNon-unit weights ~8.00 TB (7.28 TiB) ~16.00 TB (14.55 TiB)","category":"section"},{"location":"manual/large_genotype_data_streaming/#Out-of-Core-Working-Set-Math-(Original-BayesC)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Out-of-Core Working-Set Math (Original BayesC)","text":"If genotypes are streamed by chunks of c markers and decoded into Float32:\n\nchunk buffer: N*c*4 bytes\nmarker-state vectors (α, β, δ): O(P) (small relative to chunk for large N)\nresponse/residual vectors (y, yCorr): O(N) (also small relative to chunk)\n\nApproximate runtime working set:\n\nMem_working ~= 4*N*c + O(P) + O(N) bytes\n\nExample at N=500,000:\n\nChunk size c X_chunk buffer (Float32)\n128 ~256 MB\n256 ~512 MB\n512 ~1.02 GB\n1024 ~2.05 GB\n\nThis is why out-of-core design can be RAM-feasible even when dense in-memory is not.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Representation-Approaches-for-Original-BayesC","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Representation Approaches for Original BayesC","text":"","category":"section"},{"location":"manual/large_genotype_data_streaming/#1.-Dense-In-Memory-(current-baseline)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"1. Dense In-Memory (current baseline)","text":"Store dense X in RAM.\nBest arithmetic locality.\nRequires multi-terabyte RAM at this scale.\nNo extra decode overhead.","category":"section"},{"location":"manual/large_genotype_data_streaming/#2.-Dense-Out-of-Core-(mmap-style-dense-backend)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"2. Dense Out-of-Core (mmap-style dense backend)","text":"Dense storage on disk, streamed by marker sweep.\nReduces RAM requirement, but disk remains dense-scale.\n\nFor the example:\n\nDense file size (Float32): ~4.00 TB\n\nPros:\n\nlowest engineering risk\nminimal change to current math path\n\nCons:\n\nvery large disk footprint\nheavy I/O per iteration\nusually bottlenecked by storage bandwidth, not compute","category":"section"},{"location":"manual/large_genotype_data_streaming/#3.-Native-Bit-Packed-Backend-(recommended-long-term)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"3. Native Bit-Packed Backend (recommended long-term)","text":"Store genotypes in compact 2-bit representation.\nDecode on demand into small work buffers during marker updates.\n\nFor the example:\n\nPacked payload: ~250 GB (plus metadata/index overhead)\n\nPros:\n\nmajor reduction in disk footprint and read traffic\nscalable foundation for large N, P\ncan target predictable RAM via chunk size c\n\nCons:\n\nhigher engineering effort (decoder, metadata, validation)\ndecode overhead during runtime","category":"section"},{"location":"manual/large_genotype_data_streaming/#4.-External-Adapter-Backend-(e.g.,-PLINK-style-reader)","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"4. External Adapter Backend (e.g., PLINK-style reader)","text":"Reuse existing external compact format and stream into BayesC update loops.\n\nPros:\n\ninteroperability with existing data pipelines\n\nCons:\n\nparser/dependency complexity\nperformance depends on adapter implementation and access pattern","category":"section"},{"location":"manual/large_genotype_data_streaming/#Fast-Block-Implementation-(fast_blocks)-in-Large-Data-Context","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Fast-Block Implementation (fast_blocks) in Large-Data Context","text":"Although this page focuses on original BayesC (fast_blocks=false), large-data planning usually compares it to fast_blocks=true.\n\nLet:\n\nb: nominal block size\ns_i: block sizes with sum_i s_i = P\nS = sum_i s_i^2 (near-uniform approximation: S ~ P*b)\n\nCurrent block path (after removing persistent XRinvArray) is approximately:\n\nUnit weights:\nMem_block_unit ~= t * (N*P + S + P) + O(b*t)\nNon-unit weights:\nMem_block_nonunit ~= t * (2*N*P + S + P) + O(b*t)\n\nComputation scales approximately as:\n\nper outer iteration: O(NP + sum_i s_i^3) (~O(NP + P*b^2) for near-uniform blocks)\nwith JWAS outer-loop rescaling (m ~ L/b): O(LP(N/b + b))\n\nSo fast_blocks can substantially reduce arithmetic relative to original BayesC, while adding mainly the S term for XpRinvX.","category":"section"},{"location":"manual/large_genotype_data_streaming/#What-To-Watch-for-fast_blocks","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"What To Watch for fast_blocks","text":"Block-size tradeoff:\nsmaller b: less memory, weaker speedup\nlarger b: higher XpRinvX memory and heavier precompute\nEffective iteration accounting:\ncompare runs by effective updates, not only reported outer iterations\nFinal short block:\nlast block gets fewer inner repeats because nreps = block_size per block\nStartup/precompute cost:\nXpRinvX build can dominate startup on very large N,P\nMulti-trait specifics:\ncurrent multi-trait block mode behavior differs from the full non-block sampler dispatcher\nNumerical reproducibility:\nequivalent algebraic refactors may change floating-point roundoff (especially Float32)\nWeighting caveat:\nblock XRinvArray is no longer persisted, but non-unit weighted non-block xRinvArray remains a separate optimization topic","category":"section"},{"location":"manual/large_genotype_data_streaming/#Speed-and-I/O-Considerations","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Speed and I/O Considerations","text":"Original BayesC still has O(LNP) compute scaling regardless of representation. Representation changes mostly affect:\n\nfeasible RAM footprint\ndisk footprint\nI/O volume per marker sweep\n\nFor out-of-core paths, each iteration needs at least one full marker sweep. Thus, reducing per-sweep data size (e.g., dense vs 2-bit packed) directly reduces I/O pressure.","category":"section"},{"location":"manual/large_genotype_data_streaming/#I/O-lower-bound-model","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"I/O lower-bound model","text":"Ignoring compute and decode for a lower bound:\n\nT_io_per_iter >= Bytes_per_sweep / B_io\nT_io_total >= L * Bytes_per_sweep / B_io\n\nFor the worked example (Float32 dense vs 2-bit packed):\n\ndense sweep bytes: ~4,000 GB\npacked sweep bytes: ~250 GB\n\nIf B_io = 3 GB/s:\n\nStorage form I/O lower bound per iteration\nDense Float32 ~22.2 min\n2-bit packed ~1.39 min\n\nAt L=1000 iterations (I/O lower bound only):\n\nStorage form I/O lower bound total\nDense Float32 ~15.4 days\n2-bit packed ~23.1 hours\n\nThese are lower bounds; actual wall time is higher once decode and BayesC compute are included.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Side-by-Side-Summary","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Side-by-Side Summary","text":"Approach RAM feasibility at 500k x 2M Disk footprint I/O pressure Engineering effort\nDense in-memory very poor low (if already in RAM source) low low\nDense out-of-core (mmap) good very high (~4 TB, Float32) very high low\nNative 2-bit packed good moderate (~250 GB payload) much lower high\nExternal compact adapter good format-dependent (often compact) lower than dense medium-high","category":"section"},{"location":"manual/large_genotype_data_streaming/#Validation-Details-Needed-for-Large-Data-Streaming","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Validation Details Needed for Large-Data Streaming","text":"For any out-of-core backend, validate:\n\nnumerical equivalence vs dense baseline on small/medium data (α, δ, yCorr traces),\nmissing/imputation and centering consistency,\ndeterministic behavior with fixed RNG seed,\nchunk-size invariance (same results for different c within FP tolerance),\nsustained throughput and memory caps under long chains.","category":"section"},{"location":"manual/large_genotype_data_streaming/#Practical-Takeaways","page":"Handling Large Genotype Data Without Loading the Full Matrix into Memory","title":"Practical Takeaways","text":"At N=500k, P=2M, original BayesC dense in RAM is not practical on typical hardware.\nOut-of-core dense storage improves RAM feasibility but remains very heavy in disk/I/O.\nA compact backend (native bit-packed or external compact format) is the practical direction for large-scale original BayesC.\nEven with compact storage, runtime remains fundamentally O(LNP); representation helps feasibility, not asymptotic compute.","category":"section"},{"location":"examples/examples/#Examples","page":"Examples","title":"Examples","text":"link to examples wiki ","category":"section"},{"location":"manual/getstarted/#Get-Started","page":"Get Started","title":"Get Started","text":"","category":"section"},{"location":"manual/getstarted/#Installation","page":"Get Started","title":"Installation","text":"To install julia, please go to the offical Julia website. Please see platform specific instructions if you have trouble installing Julia.\n\nTo install the package, use the following command inside the Julia REPL (or IJulia Notebook):\n\nPkg.add(\"JWAS\")\n\nTo load the JWAS package, use the following command inside the Julia REPL (or IJulia Notebook):\n\nusing JWAS\n\nThe command Pkg.add(\"JWAS\") will add the registered official JWAS package and dependencies.\n\nTo use the latest/beta features under development, run Pkg.add(PackageSpec(name=\"JWAS\", rev=\"master\")) to get the newest unofficial JWAS. Run Pkg.free(\"JWAS\") to go back to the official one.","category":"section"},{"location":"manual/getstarted/#Jupyter-Notebook","page":"Get Started","title":"Jupyter Notebook","text":"If you prefer “reproducible research”, an interactive Jupyter Notebook interface is available for Julia (and therefore JWAS). The Jupyter Notebook is an open-source web application for creating and sharing documents that contain live code, equations, visualizations and explanatory text. To install IJulia for Jupyter Notebook, please go to IJulia.","category":"section"},{"location":"manual/getstarted/#Docker","page":"Get Started","title":"Docker","text":"note: Jupyter Notebooks with JWAS via Docker\nDocker provides a straightforward way to install Jupyter Notebooks with JWAS.\n\nInstall Docker from here for your platform.\nFrom a terminal (on Mac or Linux), run the command:\n\ndocker run -it --rm -p 8888:8888 qtlrocks/jwas-docker\n\nThis will start a Jupyter Notebook server listening for HTTP connections on port 8888 with a randomly generated authentication token. Examples for JWAS can be accessed from the notebook: notebooks/0_index.ipynb.\n\nThe directories and files created within the Docker container will be lost when the container is stopped. To save your work on the host machine, a directory on the host machine can be mounted as a folder in the container with the -v option. After cd into your working directory on your local machine or a server, run the command\n\ndocker run -it --rm -p 8888:8888 -v `pwd`:/home/jovyan/work qtlrocks/jwas-docker\n\nThis command creates a Docker container with the folder /home/jovyan/work with the contents of pwd of the host machine. Files and directories that are in the folder pwd will not be lost when the container is stopped.  \n\nAfter running this command, it is expected to prompt something like\n\n[I 10:41:54.774 NotebookApp] Writing notebook server cookie secret to /home/ubuntu/.local/share/jupyter/runtime/notebook_cookie_secret\n[I 10:41:54.920 NotebookApp] Serving notebooks from local directory: /home/ubuntu\n[I 10:41:54.920 NotebookApp] 0 active kernels\n[I 10:41:54.920 NotebookApp] The Jupyter Notebook is running at:\n[I 10:41:54.920 NotebookApp] http://0.0.0.0:8888/?token=75ad671f75b4c47be70591f46bec604997d8a9bd9dd51f0d\n[I 10:41:54.920 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n[C 10:41:54.921 NotebookApp]\n\n    Copy/paste this URL into your browser when you connect for the first time,\n    to login with a token:\n        http://0.0.0.0:8888/?token=75ad671f75b4c47be70591f46bec604997d8a9bd9dd51f0d\n\nThen, open the url in an internet browser (IE, Firefox, Chrome, Safari, etc) if JWAS-docker is launched on your local machine.\n\nIf you prefer running scripts using linux commands in Bash instead of Jupyter Notebook, please run the command\n\ndocker run -it --rm -v `pwd`:/home/jovyan/work qtlrocks/jwas-docker bash","category":"section"},{"location":"manual/getstarted/#Standalone-application","page":"Get Started","title":"Standalone application","text":"note: standalone application (no installation required)\nA fully self-contained application for JWAS (no installation required) will come out next year.","category":"section"},{"location":"manual/getstarted/#Access-documentation","page":"Get Started","title":"Access documentation","text":"warning: Warning\nPlease load the JWAS package at first.\n\nTo show the basic information (README file) of JWAS in REPL or IJulia notebook using ?JWAS and press enter.\n\nFor help on a specific function, type ? followed by its name, e.g. ?runMCMC and press enter in REPL or IJulia notebook.\n\nThe full documentation is available here.","category":"section"},{"location":"manual/getstarted/#Run-your-analysis","page":"Get Started","title":"Run your analysis","text":"There are several ways to run your analysis.\n\n(1) The easiest way to run analysis in Julia is by starting an interactive session (REPL) by double-clicking the Julia executable or running julia from the command line (e.g., terminal) as\n\njulia> 1+2\n3\n\njulia> 3*4\n12\n\nTo evaluate code written in a file script.jl in REPL, write and run\n\njulia> include(\"script.jl\").\n\nTo exit the interactive session, type ^D – the control key together with the d key or type quit().\n\n(2) To run code in a file non-interactively from the command line (e.g.,termial), you can give it as the first argument to the julia command:\n\njulia script.jl\n\nIf you want to pass arguments to your script, run it as\n\njulia script.jl arg1 arg2\n\nwhere arguments arg1 and arg2 are passed to your script as ARGS[1] and ARGS[2] of type String. Please see julia docs for more options.\n\n(3) To run code in Jupyter Notebook, please see IJulia.\n\n(4) To run code in Jupyter Notebook via Docker, please see Docker.","category":"section"},{"location":"theory/theory/#Some-Theory-in-JWAS","page":"Some Theory","title":"Some Theory in JWAS","text":"","category":"section"},{"location":"theory/theory/#A-Table-for-Bayesian-Linear-Mixed-Models-(BLMM)","page":"Some Theory","title":"A Table for Bayesian Linear Mixed Models (BLMM)","text":"(Image: BLMM)","category":"section"},{"location":"theory/theory/#Models","page":"Some Theory","title":"Models","text":"","category":"section"},{"location":"theory/theory/#Complete-Genomic-Data","page":"Some Theory","title":"Complete Genomic Data","text":"The general form of the multivariate (univariate) mixed effects model for individual i from n individuals with complete genomic data in JWAS is\n\n\nmathbfy_i\n =sum_j=1^p_bX_ijmathbfb_j+sum_k=1^p_uZ_ikmathbfu_k\n +sum_l=1^pM_ilboldsymbolalpha_l+mathbfe_i(1)\n\nwhere mathbfy_i is a vector of phenotypes of t traits for individual i; X_ij is the incidence matrix covariate corresponding to the jth fixed effect for individual i; mathbfb_j is a vector of jth fixed effects for the t traits; Z_ik is the incidence matrix covariate corresponding to the kth random effect for individual i; boldsymbolu_k is a vector of the kth random effects of t traits; M_il is the genotype covariate at locus l for individual i, p is the number of genotyped loci (each coded as 0,1,2), boldsymbolalpha_l is a vector of allele substitution effects or marker effects of t traits for locus j, and mathbfe_i is the vector of random residual effects of t traits for individual i. The JWAS implementation of this model involves missing phenotypes being imputed at each iteration of MCMC \\cite{sorensenGianolaBook} so that all individuals have observations for all traits. Note that when the number of traits t=1, the general form above simplifies to the single-trait  mixed effects model, and all vectors of effects in equation (1) become scalars.","category":"section"},{"location":"theory/theory/#Incomplete-Genomic-Data","page":"Some Theory","title":"Incomplete Genomic Data","text":"The general form of the multivariate (univariate) mixed effects model with incomplete genomic data (\"single-step\" methods) for non-genotyped individuals is\n\nmathbfy_i\n=sum_j=1^p_bX_ijmathbfb_j+sum_k=1^p_uZ_ikmathbfu_k+\nsum_l=1^phatM_ilboldsymbolalpha_l+sum_m=1^p_epsilonZ_nimboldsymbolepsilon_m+boldsymbole_i (2)\n\nwhere mathbfy_i is a vector of phenotypes of t traits for non-genotyped individual i;  hatM_il is the imputed genotype covariate at locus l for non-genotyped individual i, Z_nim is the incidence matrix covariate corresponding to the mth imputation residual for individual i and boldsymbolepsilon_i is a vector of imputation residuals. W_im is the incidence matrix covariate corresponding to the mth random effect for individual i. That vector of imputation residuals, boldsymbolepsilon=beginbmatrixboldsymbolepsilon_1^T  boldsymbolepsilon_2^T  ldots  endbmatrix^T, are a priori assumed to be Nleft(0(mathbfA_nn-mathbfA_ngmathbfA_gg^-1mathbfA_gn)otimesmathbfG_gright), where mathbfA_nn is the partition of the numerator relationship matrix  mathbfA that corresponds to non-genotyped individuals, mathbfA_ng or its transpose mathbfA_gn are partitions of mathbfA corresponding to relationships between non-genotyped and genotyped individuals or vice versa,  mathbfA_gg is the  partition of mathbfA that corresponds to genotyped animals, and mathbfG_g is the additive genetic covariance matrix. All the other variables are the same as in equation (1).","category":"section"},{"location":"theory/theory/#Priors","page":"Some Theory","title":"Priors","text":"","category":"section"},{"location":"theory/theory/#Priors-for-effects-other-than-markers","page":"Some Theory","title":"Priors for effects other than markers","text":"The fixed effects are assigned flat priors. The vector of random effects, mathbfu=beginbmatrixmathbfu_1^T  mathbfu_2^T  ldots  mathbfu_p_2^Tendbmatrix^T, are a priori assumed to be Nleft(0mathbfAotimesmathbfGright) with various options for mathbfA. For example, mathbfA could be an identity matrix if boldsymbolu_k is assumed to be independently and identically distributed. mathbfA can be  the numerator relationship matrix, when boldsymbolu is a vector of polygenic effects and mathbfG represents the additive-genetic variance not explained by molecular markers. Note that boldsymbolu can also be a concatenation of vectors of different types of random effects, such as litter, pen, polygenic and maternal effects. The vector boldsymbole_i of residuals are a priori assumed to be independently and identically following multivariate normal distributions with null mean and covariance matrix mathbfR, which in turn is a priori assumed to have an inverse Wishart prior distribution, W_t^-1left(mathbfS_enu_eright). Note that when number of traits t=1, the priors for mathbfG and mathbfR in single-trait analyses follow scaled inverted chi-square distributions.","category":"section"},{"location":"theory/theory/#Priors-for-marker-effects","page":"Some Theory","title":"Priors for marker effects","text":"","category":"section"},{"location":"theory/theory/#single-trait-BayesA","page":"Some Theory","title":"single-trait BayesA","text":"The prior assumption is that marker effects have identical and independent univariate-t distributions each with a null mean, scale parameter S^2_alpha and nu degrees of freedom. This is equivalent to assuming that the marker effect at locus i has a univariate normal with null mean and unknown, locus-specific variance sigma^2_i, which in turn is assigned a scaled inverse chi-square prior with scale parameter S^2_alpha and nu_alpha degrees of freedom.","category":"section"},{"location":"theory/theory/#single-trait-BayesB","page":"Some Theory","title":"single-trait BayesB","text":"In BayesB, the prior assumption is that marker effects have identical and independent mixture distributions, where each has a point mass at zero with probability pi and a univariate-t distribution with probability 1-pi having a null mean, scale parameter S^2_alpha and nu degrees of freedom. Thus, BayesA is a special case of BayesB with pi=0. Further, as in BayesA, the t-distribution in BayesB is equivalent to a univariate normal with null mean and unknown, locus-specific variance, which in turn is assigned a scaled inverse chi-square prior with scale parameter S^2_alpha and nu_alpha degrees of freedom. (A fast and efficient Gibbs sampler was implemented for BayesB in JWAS.)","category":"section"},{"location":"theory/theory/#single-trait-BayesC-and-BayesC\\pi","page":"Some Theory","title":"single-trait BayesC and BayesCpi","text":"In BayesC, the prior assumption is that marker effects have identical and independent mixture distributions, where each has a point mass at zero with probability pi and a univariate-normal distribution with probability 1-pi having a null mean and variance sigma^2_alpha, which in turn has a scaled inverse chi-square prior with scale parameter S^2_alpha and nu_alpha degrees of freedom. In addition to the above assumptions, in BayesC pi, pi is treated as unknown with a uniform prior.","category":"section"},{"location":"theory/theory/#multiple-trait-Bayesian-Alphabet","page":"Some Theory","title":"multiple-trait Bayesian Alphabet","text":"In multi-trait BayesCPi, the prior for alpha_lk, the marker effect of trait k for locus l, is a mixture with a point mass at zero and a univariate normal distribution conditional on sigma_k^2:\n\nalpha_lkmidpi_ksigma_k^2  begincases\nsim Nleft(0sigma_k^2right)   probability(1-pi_k)\n0   probabilitypi_k\nendcases\n\nand the covariance between effects for traits k and k at the same locus, i.e., alpha_lk and alpha_lk^ is\n\ncovleft(alpha_lkalpha_lk^midsigma_kk^right)=begincases\nsigma_kk^  ifbothalpha_lkneq0andalpha_lk^neq0\n0  otherwise\nendcases\n\nThe vector of marker effects at a particular locus boldsymbolalpha_l is written as boldsymbolalpha_l=boldsymbolD_lboldsymbolbeta_l, where boldsymbolD_l is a diagonal matrix with elements diagleft(boldsymbolD_lright)=boldsymboldelta_l=left(delta_l1delta_l2delta_l3ldotsdelta_ltright), where delta_lk is an indicator variable indicating whether the marker effect of locus l for trait k is zero or non-zero, and the vector boldsymbolbeta_l follows a multivariate normal distribution with null mean and covariance matrix boldsymbolG. The covariance matrix boldsymbolG is a priori assumed to follow an inverse Wishart distribution, W_t^-1left(mathbfS_betanu_betaright).\n\nIn the most general case, any marker effect might be zero for any possible combination of t traits resulting in 2^t possible combinations of boldsymboldelta_l. For example, in a t=2 trait model, there are 2^t=4 combinations for  boldsymboldelta_l: (00), (01), (10), (11). Suppose in general we use numerical labels \"1\", \"2\",ldots, \"l\" for the 2^t possible outcomes for  boldsymboldelta_l, then the prior for  boldsymboldelta_l is a categorical distribution\n\npleft(boldsymboldelta_l=iright)= Pi_1Ileft(boldsymboldelta_l=1right)+Pi_2Ileft(boldsymboldelta_l=2right)++Pi_lIleft(boldsymboldelta_l=lright)\n\nwhere sum_i=1^lPi_i=1 with Pi_i being the prior probability that the vector boldsymboldelta_l corresponds to the vector labelled i. A Dirichlet distribution with all parameters equal to one, i.e., a uniform distribution, can be used for the prior for boldsymbolPi=left(Pi_1Pi_2Pi_lright).   \n\nThe differences in multi-trait BayesB method is that the prior for boldsymbolbeta_l is a multivariate t distribution, rather than a multivariate normal distribution. This is equivalent to assuming boldsymbolbeta_l has a multivariate normal distribution with null mean and locus-specific covariance matrix boldsymbolG_l, which is assigned an inverse Wishart prior, W_t^-1left(mathbfS_betanu_betaright). Multi-trait BayesA method is a special case of multi-trait BayesB method where boldsymboldelta_l is always a vector of ones.\n\nreferencesMeuwissen T, Hayes B, Goddard M. Prediction of total genetic value using genome-wide dense marker maps. Genetics, 2001,157:1819–1829.\nFernando R, Garrick D. Bayesian methods applied to GWAS. Methods Mol Biol. 2013, 1019:237–274.\nCheng H, Garrick D, Fernando R. A fast and efficient Gibbs sampler for BayesB in whole- genome analyses. Genetics Selection Evolution, 2015, 47:80.\nFernando R, Dekkers J, Garrick D. A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses. Genetics Selection Evolution, 2015, 46(1), 50.\nFernando R, Cheng H, Golden B, Garrick D.. Computational strategies for alternative single-step Bayesian regression models with large numbers of genotyped and non-genotyped animals. Genetics Selection Evolution, 2016, 48(1), 96.\nCheng H, Kizilkaya K, Zeng J, Garrick D, Fernando R. Genomic Prediction from Multiple-trait Bayesian Regression Methods using Mixture Priors. Genetics. 2018, 209(1).","category":"section"},{"location":"manual/workflow/#Workflow","page":"Workflow","title":"Workflow","text":"A step by step workflow for how to run JWAS is shown in this section. The workflow below is used to demonstrate a three-trait Bayesian linear mixed model fitting fixed effects (x1, x3), random effects (x2), direct genetic effects (ID), maternal genetic effects (dam) and genomic information.\n\nPages = [\n  \"workflow.md\"\n]\nDepth = 2","category":"section"},{"location":"manual/workflow/#Available-Models","page":"Workflow","title":"Available Models","text":"Given the data and model equations, several different types of models are available in JWAS as shown below. In the table below, \"X\" denotes the type of available data, and \"Y<=A\" denotes that Y individuals is a subset of A individuals.  \n\nLinear Mixed Models (LMM) phenotypes (Y) pedigree (A) genotypes (G) notes\nConventional LMM X   \nPedigree-based LMM X X  Y<=A\nComplete Genomic LMM X optional X Y<=G\nIncomplete Genomic LMM X X X Y<=A,G<=A\n\nnote: Note\nIncomplete Genomic LMM is also called \"single-step\" methods in animal breeding.\nPedigree information may be used in Complete Genomic LMM for extra polygenic effects to account for genetic variance not explained by the genomic data (e.g., SNPs).\nPedigree-based LMM (none of the individuals in the pedigree are genotyped) and Complete Genomic LMM (all individuals in the pedigree are genotyped) are special cases of Incomplete Genomic LMM (part of the individuals in the pedigree are genotyped).","category":"section"},{"location":"manual/workflow/#Get-Data-Ready","page":"Workflow","title":"Get Data Ready","text":"By default, input data files are comma-separated values (CSV) files, where each line of the file consists of one or more fields, separated by commas. Other field separators such as space (' ') or tab ('\\t') can be used if you supply the keyword argument, e.g, CSV.read(...,delim='\\t') or add_genotypes(...,separator='\\t')\n\nClick on the buttons inside the tabbed menu to see the data:\n\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\nbody {font-family: Arial;}\n\n/* Style the tab */\n.tab {\n    overflow: hidden;\n    border: 1px solid #ccc;\n    background-color: #f1f1f1;\n}\n\n/* Style the buttons inside the tab */\n.tab button {\n    background-color: inherit;\n    float: left;\n    border: none;\n    outline: none;\n    cursor: pointer;\n    padding: 14px 16px;\n    transition: 0.3s;\n    font-size: 17px;\n}\n\n/* Change background color of buttons on hover */\n.tab button:hover {\n    background-color: #ddd;\n}\n\n/* Create an active/current tablink class */\n.tab button.active {\n    background-color: #ccc;\n}\n\n/* Style the tab content */\n.tabcontent {\n    display: none;\n    padding: 6px 12px;\n    border: 1px solid #ccc;\n    border-top: none;\n}\n</style>\n</head>\n<body>\n\n<div class=\"tab\">\n  <button class=\"tablinks\" onclick=\"openCity(event, 'phenotypes')\">phenotypes.txt</button>\n  <button class=\"tablinks\" onclick=\"openCity(event, 'pedigree')\">pedigree.txt</button>\n  <button class=\"tablinks\" onclick=\"openCity(event, 'genotypes')\">genotypes.txt</button>\n  <button class=\"tablinks\" onclick=\"openCity(event, 'map file')\">map.txt</button>\n</div>\n\n<div id=\"phenotypes\" class=\"tabcontent\">\n<p>ID,y1,y2,y3,x1,x2,x3,dam</p>\n<p>a1,-0.06,3.58,-1.18,0.9,2,m,NA</p>\n<p>a2,-0.6,4.9,0.88,0.3,1,f,NA</p>\n<p>a3,-2.07,3.19,0.73,0.7,2,f,NA</p>\n<p>a4,-2.63,6.97,-0.83,0.6,1,m,a2</p>\n<p>a5,2.31,3.5,-1.52,0.4,2,m,a2</p>\n<p>a6,0.93,4.87,-0.01,05,2,f,a3</p>\n<p>a7,-0.69,3.1,-1.47,0.5,2,f,a3</p>\n<p>a8,-4.69,7.31,-1.09,0.3,2,m,a6</p>\n<p>a9,-2.81,7.18,0.76,0.4,2,m,a6</p>\n<p>a10,1.92,1.78,-0.88,0.2,1,m,a7</p>\n</div>\n\n<div id=\"pedigree\" class=\"tabcontent\">\n<p>ID,Sire,Dam</p>\n<p>a1,0,0</p>\n<p>a2,0,0</p>\n<p>a3,0,0</p>\n<p>a4,a1,a2</p>\n<p>a5,a1,a2</p>\n<p>a6,a1,a3</p>\n<p>a7,a1,a3</p>\n<p>a8,a4,a6</p>\n<p>a9,a4,a6</p>\n<p>a10,a5,a7</p>\n</div>\n\n<div id=\"genotypes\" class=\"tabcontent\">\n<p>ID,m1,m2,m3,m4,m5</p>\n<p>a1,1,2,1,1,0</p>\n<p>a2,2,1,1,1,1</p>\n<p>a3,1,1,0,1,1</p>\n<p>a4,2,2,0,1,0</p>\n<p>a5,1,1,2,1,1</p>\n<p>a6,2,1,0,0,0</p>\n<p>a7,0,2,1,2,1</p>\n<p>a8,2,2,0,0,0</p>\n<p>a9,2,1,0,1,0</p>\n<p>a10,0,2,2,2,1</p>\n</div>\n\n<div id=\"map file\" class=\"tabcontent\">\n<p>markerID,chromosome,position</p>\n<p>m1,1,16977</p>\n<p>m2,1,434311</p>\n<p>m3,1,1025513</p>\n<p>m4,2,70350</p>\n<p>m5,2,101135</p>\n</div>\n\n\n<script>\nfunction openCity(evt, cityName) {\n    var i, tabcontent, tablinks;\n    tabcontent = document.getElementsByClassName(\"tabcontent\");\n    for (i = 0; i < tabcontent.length; i++) {\n        tabcontent[i].style.display = \"none\";\n    }\n    tablinks = document.getElementsByClassName(\"tablinks\");\n    for (i = 0; i < tablinks.length; i++) {\n        tablinks[i].className = tablinks[i].className.replace(\" active\", \"\");\n    }\n    document.getElementById(cityName).style.display = \"block\";\n    evt.currentTarget.className += \" active\";\n}\n</script>\n</body>","category":"section"},{"location":"manual/workflow/#Step-1:-Load-Packages","page":"Workflow","title":"Step 1: Load Packages","text":"using JWAS,CSV,DataFrames\n\n\n\nThe JWAS package is loaded, as well as the CSV and DataFrame packages for reading text files.","category":"section"},{"location":"manual/workflow/#Step-2:-Read-Data","page":"Workflow","title":"Step 2: Read Data","text":"","category":"section"},{"location":"manual/workflow/#Read-Phenotypic-Data","page":"Workflow","title":"Read Phenotypic Data","text":"phenotypes = CSV.read(\"phenotypes.txt\",DataFrame,delim = ',',header=true,,missingstrings=[\"NA\"])\nfirst(phenotypes)\n\noutput:\n\n6×8 DataFrames.DataFrame\n│ Row │ ID │ y1    │ y2   │ y3    │ x1  │ x2 │ x3 │ dam       │\n├─────┼────┼───────┼──────┼───────┼─────┼────┼────┼───────────┤\n│ 1   │ a1 │ -0.06 │ 3.58 │ -1.18 │ 0.9 │ 2  │ m  │ missing   │\n│ 2   │ a2 │ -0.6  │ 4.9  │ 0.88  │ 0.3 │ 1  │ f  │ missing   │\n│ 3   │ a3 │ -2.07 │ 3.19 │ 0.73  │ 0.7 │ 2  │ f  │ missing   │\n│ 4   │ a4 │ -2.63 │ 6.97 │ -0.83 │ 0.6 │ 1  │ m  │ a2        │\n│ 5   │ a5 │ 2.31  │ 3.5  │ -1.52 │ 0.4 │ 2  │ m  │ a2        │\n│ 6   │ a6 │ 0.93  │ 4.87 │ -0.01 │ 5.0 │ 2  │ f  │ a3        │\n\n\n\nThe phenotypic data is read on line 1. On line 2, the first several rows of the phenotypic data are shown.","category":"section"},{"location":"manual/workflow/#Read-Pedigree-Data","page":"Workflow","title":"Read Pedigree Data","text":"pedigree   = get_pedigree(\"pedigree.txt\",separator=\",\",header=true)\n\nlink to documentation for get_pedigree\n\n\n\nThe pedigree data is read on line 1.","category":"section"},{"location":"manual/workflow/#Read-Genomic-Data","page":"Workflow","title":"Read Genomic Data","text":"genotypes  = get_genotypes(\"genotypes.txt\",G,method=\"BayesC\",separator=\",\",header=true) #G is optional\n\nlink to documentation for get_genotypes\n\n\n\nOn line 1, the genomic information is read on line 1 with the genotype file.  and variance G (a 3x3 matrix). In Bayesian analysis, the G is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\n\nDense loading shown above is the default and primary workflow (storage=:dense).\n\nFor very large marker panels, an optional streaming backend is available:\n\nprefix = prepare_streaming_genotypes(\\\"genotypes.txt\\\",separator=',',header=true)\ngenotypes = get_genotypes(prefix,G,method=\\\"BayesC\\\",storage=:stream) #G is optional\n\nStreaming mode is currently an MVP path (single-trait BayesC, fast_blocks=false, unit residual weights, double_precision=false, exact genotype/phenotype ID order).","category":"section"},{"location":"manual/workflow/#Step-3:-Build-Model-Equations","page":"Workflow","title":"Step 3: Build Model Equations","text":"model_equation = \"y1 = intercept + x1 + x3 + ID + dam + genotypes\n                  y2 = intercept + x1 + x2 + x3 + ID + genotypes\n                  y3 = intercept + x1 + x1*x3 + x2 + ID + genotypes\"\nmodel=build_model(model_equation,R) #R is optional\n\nlink to documentation for build_model\n\n\n\nThe model equation for a 3-trait analysis is defined on the first 3 lines.\n\nThe effects fitted in the model for trait y1 are the intercept, x1, x3, direct genetic effects (ID), maternal genetic effects (dam), and molecular marker effects (genotypes).\nThe effects fitted in the model for trait y2 are the intercept, x1, x2, x3, direct genetic effects (ID), and molecular marker effects (genotypes).\nThe effects fitted in the model for trait y3 are the intercept, x1, the interaction between x1 and x3, x2, direct genetic effects (ID), and , and molecular marker effects (genotypes).\n\nOn the last line, the model is built given the model equation and residual variance R (a 3x3 matrix). In Bayesian analysis, R is the mean for the prior assigned for the residual variance with degree of freedom df, defaulting to 4.0. If R is not provided, a value is calculated from responses (phenotypes). By default, all effects are treated as fixed and classed as factors (categorical variables) rather than covariates (quantitative variables).","category":"section"},{"location":"manual/workflow/#Step-4:-Set-Factors-or-Covariate","page":"Workflow","title":"Step 4: Set Factors or Covariate","text":"set_covariate(model,\"x1\")\n\nlink to documentation for set_covariate\n\n\n\nOn line 1, the effect x1 is defined to be a covariate (a quantitative variable) rather than a factor (a categorical variable).","category":"section"},{"location":"manual/workflow/#Step-5:-Set-Random-or-Fixed-Effects","page":"Workflow","title":"Step 5: Set Random or Fixed Effects","text":"set_random(model,\"x2\",G1) #G1 is optional\nset_random(model,\"ID dam\",pedigree,G2) #G2 is optional\n\nlink to documentation for set_random\n\n\n\nOn line 1, the x2 class effect is defined as random with variance G1(a 2x2 matrix). On line 2, direct genetic effects and maternal genetic effects are fitted as ID and dam with G2 (a 4x4 matrix) and the inverse of the numerator relationship matrix defined from pedigree. In Bayesian analysis, G1 and G2 are the means for the priors assigned for the variances with degree of freedom df, defaulting to 4.0. If G1 or G2 is not provided, a value is calculated from responses (phenotypes).","category":"section"},{"location":"manual/workflow/#Step-6:-Run-Bayesian-Analysis","page":"Workflow","title":"Step 6: Run Bayesian Analysis","text":"outputMCMCsamples(model,\"dam\")\nout=runMCMC(model,phenotypes)\n\nlink to documentation for outputMCMCsamples\nlink to documentation for runMCMC\n\n\n\nOn line 1, MCMC samples from runMCMC for x2 is saved to a file, where each row represents one sample from the MCMC. On line 2, a multi-trait BayesC analysis is performed with model and phenotypes as had been defined in step 1-6. MCMC samples for marker effects, location parameters specified on line 1, and all variance components from this analysis are saved every output_samples_frequency iterations to files.\n\nFor large marker panels, runMCMC(...; fast_blocks=...) enables the block BayesC path. See Block BayesC for algorithm details and speed/memory tradeoffs. For a real cluster benchmark comparing fast_blocks=true vs fast_blocks=false at target scale (N=50,000, P=2,000,000, chain_length=2000), see Benchmark. For standard original BayesC (fast_blocks=false) at very large N and P, see Handling Large Genotype Data Without Loading the Full Matrix into Memory for memory/speed tradeoffs across storage approaches. For feature-level details of the opt-in streaming backend (storage=:stream), including API and benchmarks, see Streaming Genotype Backend (BayesC MVP). For complete SEM usage, reference behavior, and implementation notes, see SEM: Beginner to Advanced.\n\n\n\nSeveral steps above can be skipped if no related information is available, e.g., step 4 is skipped if all effects are classed as factors. Several detailed examples are available in the examples section. Here is the link to documentation for all Public functions.","category":"section"},{"location":"manual/workflow/#check-results","page":"Workflow","title":"check results","text":"Posterior means (estimate) and standard deviations (SD) of location parameters, most variance components, and marker effects are saved as the variable out and in text files. They can be listed and obtained as\n\nkeys(out)\n\n# output:\n#\n# Base.KeyIterator for a Dict{Any,Any} with 7 entries. Keys:\n#   \"polygenic effects covariance matrix\"\n#   \"Model frequency\"\n#   \"residual covariance matrix\"\n#   \"marker effects\"\n#   \"marker effects variance\"\n#   \"location parameters\"\n#   \"Pi\"\n\nout[\"residual variance\"]\n\n# output:\n#\n#Covariance\tEstimate\tSD\n#y1_y1\t1.65265\t0.29405\n#y1_y2\t-0.0290279\t0.02347\n#y1_y3\t-0.252009\t0.048289\n#y2_y1\t-0.0290279\t0.02347\n#y2_y2\t0.977405\t0.009732\n#y2_y3\t0.0451994\t0.095828\n#y3_y1\t-0.252009\t0.048289\n#y3_y2\t0.0451994\t0.095828\n#y3_y3\t0.363878\t0.049278\n\n\nIn addition, MCMC samples from posterior distributions of marker effects, all variance components, and location parameters specified in step 7, are saved to text files in your working directory. Users can compute the posterior distributions of parameters of interest using these MCMC samples files. A list of output files are shown below.","category":"section"},{"location":"manual/workflow/#Output-files:","page":"Workflow","title":"Output files:","text":"Below is a list of files containing estimates and standard deviations for variables of interest. \n\nfile name description\nEBV_y1.txt estimated breeding values for trait named \"y1\"\nEBV_y2.txt estimated breeding values for trait named \"y2\"\nEBV_y3.txt estimated breeding values for trait named \"y3\"\ngenetic_variance.txt estimated genetic variance-covariance for all traits\nheritability.txt estimated heritability\nlocation_parameters.txt estimated non-genetic effects\npi_genotypes.txt estimated pi\npolygeniceffectscovariance_matrix.txt estimated variance-covariance between polygenic effects (y1ID, y2ID, y3ID, y1dam)\nmarkereffectsgenotypes.txt estimated marker effects for all traits\nresidual_variance.txt estimated residual variance-covariance for all traits\n\nBelow is a list of files containing MCMC samples for variables of interest. \n\nfile name description\nMCMCsamplesEBV_y1.txt MCMC samples from the posterior distribution of breeding values for trait named \"y1\"\nMCMCsamplesEBV_y2.txt MCMC samples from the posterior distribution of breeding values for trait named \"y2\"\nMCMCsamplesEBV_y3.txt MCMC samples from the posterior distribution of breeding values for trait named \"y3\"\nMCMCsamplesgenetic_variance.txt MCMC samples from the posterior distribution of genetic variance-covariance for all traits\nMCMCsamplesheritability.txt MCMC samples from the posterior distribution of heritability\nMCMCsamplesmarkereffectsgenotypes_y1 MCMC samples from the posterior distribution of marker effects for trait named \"y1\"\nMCMCsamplesmarkereffectsgenotypes_y2 MCMC samples from the posterior distribution of marker effects for trait named \"y2\"\nMCMCsamplesmarkereffectsgenotypes_y3 MCMC samples from the posterior distribution of marker effects for trait named \"y3\"\nMCMCsamplesmarkereffectsvariances_genotypes.txt MCMC samples from the posterior distribution of marker effect variance for all traits\nMCMCsamplespi_genotypes.txt MCMC samples from the posterior distribution of pi\nMCMCsamplespolygeniceffectsvariance.txt MCMC samples from the posterior distribution of variance-covariance between y1ID, y2ID, y3ID, y1dam\nMCMCsamplesresidual_variance.txt MCMC samples from the posterior distribution of residual variance-covariance for all traits\nMCMCsamplesy1.dam.txt MCMC samples from the posterior distribution of dam effect for y1\nMCMCsamplesy1.IDy2.IDy3.IDy1.damvariances.txt MCMC samples from the posterior distribution of variance-covariance between y1ID, y2ID, y3ID, y1dam\nMCMCsamplesy2.x2y3.x2variances.txt MCMC samples from the posterior distribution of variance-covariance between y2x2 and y3x2","category":"section"},{"location":"manual/public/#Public-functions","page":"Public","title":"Public functions","text":"Documentation for JWAS.jl's public interface. Below are functions available to general users.","category":"section"},{"location":"manual/public/#Index","page":"Public","title":"Index","text":"Pages = [\"public.md\"]\nModules = [JWAS]","category":"section"},{"location":"manual/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"manual/public/#JWAS.build_model","page":"Public","title":"JWAS.build_model","text":"build_model(model_equations::AbstractString,R=false; df::AbstractFloat=4.0, estimate_variance=true)\n\nBuild a model from model equations with the residual variance R. In Bayesian analysis, R is the mean for the prior assigned for the residual variance with degree of freedom df, defaulting to 4.0. If R is not provided, a value is calculated from responses (phenotypes).\nBy default, all variabels in modelequations are factors (categorical) and fixed. Set variables to be covariates (continuous) or random using functions `setcovariate()orset_random()`.\nThe argument estimate_variance indicates whether to estimate the residual variance; estimate_variance=true is the default.\n\n#single-trait\nmodel_equations = \"BW = intercept + age + sex\"\nR               = 6.72\nmodels          = build_model(model_equations,R);\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex\n                   CW = intercept + litter\";\nR               = [6.72   24.84\n                   24.84  708.41]\nmodels          = build_model(model_equations,R);\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.PedModule.get_pedigree","page":"Public","title":"JWAS.PedModule.get_pedigree","text":"get_pedigree(pedfile::AbstractString;header=false,separator=',',missingstrings=[\"0\"])\n\nGet pedigree informtion from a pedigree file with header (defaulting to false) , separator (defaulting to ,) and missing values (defaulting to [\"0\"])\nPedigree file format:\n\na,0,0\nc,a,b\nd,a,c\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.get_genotypes","page":"Public","title":"JWAS.get_genotypes","text":"get_genotypes(file::Union{AbstractString,Array{Float64,2},Array{Float32,2},Array{Int64,2}, Array{Int32,2}, Array{Any,2}, DataFrames.DataFrame}, G = false;\n              ## method:\n              method = \"BayesC\",Pi = 0.0,estimatePi = true, \n              ## variance:\n              G_is_marker_variance = false, df = 4.0,\n              estimate_variance=true, estimate_scale=false,\n              constraint = false, #for multi-trait only, constraint=true means no genetic covariance among traits\n              ## format:\n              separator=',',header=true,\n              ## quality control:\n              quality_control=true, MAF = 0.01, missing_value = 9.0,\n              ## others:\n              center=true,starting_value=false,\n              storage=:dense)\n\nGet marker informtion from a genotype file/matrix. This file needs to be column-wise sorted by marker positions.\nIf a text file is provided, the file format should be:\n\nAnimal,marker1,marker2,marker3,marker4,marker5\nS1,1,0,1,1,1\nD1,2,0,2,2,1\nO1,1,2,0,1,0\nO3,0,0,2,1,1\n\nIf a DataFrame is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nThe first column in the DataFrame should be individual IDs\nThe marker IDs can be provided as the header of the DataFrame. If omitted, marker IDs will be set to 1,2,3...\nIf an nxp Matrix of genotypes (Array) is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nIndividual IDs will be set to 1:n; \nMarker IDs will be set to 1:p\nIf quality_control=true, defaulting to true,\nMissing genotypes should be denoted as 9, and will be replaced by column means. Users can also impute missing genotypes before the analysis.\nMinor allele frequency MAF threshold, defaulting to 0.01, is uesd, and fixed loci are removed.\nG is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nAvailable methods include \"conventional (no markers)\", \"RR-BLUP\", \"BayesA\", \"BayesB\", \"BayesC\", \"Bayesian Lasso\", and \"GBLUP\".\nIn Bayesian variable selection methods, Pi for single-trait analyses is a number; Pi for multi-trait analyses is a dictionary such as Pi=Dict([1.0; 1.0]=>0.7,[1.0; 0.0]=>0.1,[0.0; 1.0]=>0.1,[0.0; 0.0]=>0.1), defaulting to all markers have effects (Pi = 0.0) in single-trait analysis and all markers have effects on all traits (Pi=Dict([1.0; 1.0]=>1.0,[0.0; 0.0]=>0.0)) in multi-trait analysis. Pi is estimated if estimatePi = true, , defaulting to false.\nScale parameter for prior of marker effect variance is estimated if estimate_scale = true, defaulting to false.\nstorage=:dense (default) keeps the existing in-memory dense loading behavior. storage=:stream loads an opt-in packed backend prepared by prepare_streaming_genotypes.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.set_covariate","page":"Public","title":"JWAS.set_covariate","text":"set_covariate(model::MME,variables::AbstractString...)\n\nset variables as covariates; model is the output of function build_model().\n\n#After running build_model, variabels age and year can be set to be covariates as\nset_covariate(model,\"age\",\"year\")\n#or\nset_covariate(model,\"age year\")\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.set_random","page":"Public","title":"JWAS.set_random","text":"set_random(mme::MME,randomStr::AbstractString,ped::Pedigree, G;df=4)\n\nset variables as random polygenic effects with pedigree information ped. and variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\n\n#single-trait (example 1)\nmodel_equation  = \"y = intercept + age + animal\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = 1.6\nset_random(model,\"animal\", ped, G)\n\n#single-trait (example 2)\nmodel_equation  = \"y = intercept + age + animal + animal*age\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = [1.6   0.2\n                   0.2  1.0]\nset_random(model,\"animal animal*age\", ped,G)\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex + animal\n                   CW = intercept + age + sex + animal\"\nmodel           = build_model(model_equations,R);\nped             = get_pedigree(pedfile);\nG               = [6.72   2.84\n                   2.84  8.41]\nset_random(model,\"animal\",ped,G)\n\n\n\n\n\nset_random(mme::MME,randomStr::AbstractString,G;Vinv=0,names=[],df=4)\n\nset variables as random effects, defaulting to i.i.d effects, with variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nthe random effects are assumed to be i.i.d by default and it can be defined with any (inverse of) covariance structure Vinv with its index (row names) provided by names.\n\n#single-trait (i.i.d randome effects)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nG               = 0.6\nset_random(model,\"litter\",G)\n\n#multi-trait (i.i.d randome effects)\nmodel_equations = \"BW = intercept + litter + sex\n                   CW = intercept + litter + sex\"\nmodel           = build_model(model_equations,R);\nG               = [3.72  1.84\n                   1.84  3.41]\nset_random(model,\"litter\",G)\n\n#single-trait (randome effects with specific covariance structures)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nV               = [1.0  0.5 0.25\n                   0.5  1.0 0.5\n                   0.25 0.5 1.0]\nG               = 0.6\nset_random(model,\"litter\",G,Vinv=inv(V),names=[a1;a2;a3])\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.runMCMC","page":"Public","title":"JWAS.runMCMC","text":"runMCMC(model::MME,df::DataFrame;\n        #Data\n        heterogeneous_residuals           = false,\n        #MCMC\n        chain_length::Integer             = 100,\n        starting_value                    = false,\n        burnin::Integer                   = 0,\n        output_samples_frequency::Integer = chain_length>1000 ? div(chain_length,1000) : 1,\n        update_priors_frequency::Integer  = 0,\n        #Methods\n        single_step_analysis            = false, #parameters for single-step analysis\n        pedigree                        = false, #parameters for single-step analysis\n        fitting_J_vector                = true,  #parameters for single-step analysis\n        categorical_trait               = false,\n        censored_trait                  = false,\n        causal_structure                = false,\n        mega_trait                      = false,\n        missing_phenotypes              = true,\n        constraint                      = false,\n        #Genomic Prediction\n        outputEBV                       = true,\n        output_heritability             = true,\n        prediction_equation             = false,\n        #MISC\n        seed                            = false,\n        printout_model_info             = true,\n        printout_frequency              = chain_length+1,\n        big_memory                      = false,\n        double_precision                = false,\n        fast_blocks                     = false,\n        memory_guard                    = :error,\n        memory_guard_ratio              = 0.80,\n        ##MCMC samples (defaut to marker effects and hyperparametes (variance components))\n        output_folder                     = \"results\",\n        output_samples_for_all_parameters = false,\n        ##for deprecated JWAS\n        methods                         = \"conventional (no markers)\",\n        Pi                              = 0.0,\n        estimatePi                      = false)\n\nRun MCMC for Bayesian Linear Mixed Models with or without estimation of variance components.\n\nMarkov chain Monte Carlo\nThe first burnin iterations are discarded at the beginning of a MCMC chain of length chain_length.\nSave MCMC samples every output_samples_frequency iterations, defaulting to chain_length/1000, to a folder output_folder, defaulting to results. MCMC samples for hyperparametes (variance componets) and marker effects are saved by default. MCMC samples for location parametes can be saved using function output_MCMC_samples(). Note that saving MCMC samples too frequently slows down the computation.\nThe starting_value can be provided as a vector for all location parameteres and marker effects, defaulting to 0.0s. The order of starting values for location parameters and marker effects should be the order of location parameters in the Mixed Model Equation for all traits (This can be obtained by getNames(model)) and then markers for all traits (all markers for trait 1 then all markers for trait 2...).\nMiscellaneous Options\nPriors are updated every update_priors_frequency iterations, defaulting to 0.\nMethods\nSingle step analysis is allowed if single_step_analysis = true and pedigree is provided.\nMiscellaneous Options\nMissing phenotypes are allowed in multi-trait analysis with missing_phenotypes=true, defaulting to true.\nCatogorical Traits are allowed if categorical_trait=true, defaulting to false. Phenotypes should be coded as 1,2,3...\nCensored traits are allowed if the upper bounds are provided in censored_trait as an array, and lower bounds are provided as phenotypes.\nIf constraint=true, defaulting to false, constrain residual covariances between traits to be zeros.\nIf causal_structure is provided, e.g., causal_structure = [0.0 0.0 0.0;1.0 0.0 0.0;1.0 0.0 0.0] for trait 1 -> trait 2 and trait 1 -> trait 3 (column index affacts row index, and a lower triangular matrix is required), phenotypic causal networks will be incorporated using structure equation models.\nGenomic Prediction\nPredicted values for individuals of interest can be obtained based on a user-defined prediction equation prediction_equation, e.g., \"y1:animal + y1:age\".\nFor now, genomic data is always included. Genetic values including effects defined with genotype and pedigree information are returned if prediction_equation= false, defaulting to false.\nIndividual estimted genetic values and prediction error variances (PEVs) are returned if outputEBV=true, defaulting to true. Heritability and genetic\nvariances are returned if output_heritability=true, defaulting to true. Note that estimation of heritability is computaionally intensive.\nMiscellaneous Options\nPrint out the model information in REPL if printout_model_info=true; print out the monte carlo mean in REPL with printout_frequency, defaulting to false.\nIf seed, defaulting to false, is provided, a reproducible sequence of numbers will be generated for random number generation.\nIf big_memory=true, defaulting to false, a machine with  lots of memory is assumed which may speed up the analysis.\nmemory_guard controls the marker-memory precheck before MCMC (:error, :warn, :off; default :error).\nmemory_guard_ratio sets the allowed fraction of Sys.total_memory() for the precheck (default 0.80).\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.outputEBV","page":"Public","title":"JWAS.outputEBV","text":"outputEBV(model,IDs::Array)\n\nOutput estimated breeding values and prediction error variances for IDs.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.outputMCMCsamples","page":"Public","title":"JWAS.outputMCMCsamples","text":"outputMCMCsamples(mme::MME,trmStrs::AbstractString...)\n\nGet MCMC samples for specific location parameters.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#DataAPI.describe","page":"Public","title":"DataAPI.describe","text":"describe(model::MME)\n\nPrint out model information.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.solve","page":"Public","title":"JWAS.solve","text":"solve(mme::MME,df::DataFrame;solver=\"default\",printout_frequency=100,tolerance = 0.000001,maxiter = 5000)\n\nSolve the mixed model equations (no marker information) without estimating variance components.\n\nAvailable solvers include default, Jacobi, Gauss-Seidel, and Gibbs sampler.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.GWAS","page":"Public","title":"JWAS.GWAS","text":"GWAS(marker_effects_file;header=true)\n\nCompute the model frequency for each marker (the probability the marker is included in the model) using samples of marker effects stored in markereffectsfile.\n\n\n\n\n\nGWAS(model,map_file,marker_effects_file...;\n     window_size = \"1 Mb\",sliding_window = false,\n     GWAS = true, threshold = 0.001,\n     genetic_correlation = false,\n     header = true)\n\nrun genomic window-based GWAS\n\nMCMC samples of marker effects are stored in markereffectsfile with delimiter ','.\nmodel is either the model::MME used in analysis or the genotype cavariate matrix M::Array\nmap_file has the (sorted) marker position information with delimiter ','. If the map file is not provided, i.e., map_file=false, a fake map file will be generated with window_size markers in each 1 Mb window, and each 1 Mb window will be tested.\nIf two markereffectsfile are provided, and genetic_correlation = true, genomic correlation for each window is calculated.\nStatistics are computed for nonoverlapping windows of size window_size by default. If sliding_window = true, those for overlapping sliding windows are calculated.\nmap file format:\n\nmarkerID,chromosome,position\nm1,1,16977\nm2,1,434311\nm3,1,1025513\nm4,2,70350\nm5,2,101135\n\n\n\n\n\n","category":"function"},{"location":"citing/citing/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing/citing/#Software","page":"Citing","title":"Software","text":"Cheng, H., Fernando, R. L., and Garrick, D. J. 2018 JWAS: Julia implementation of whole-genome analysis software. Proceedings of the World Congress on Genetics Applied to Livestock Production,11.859. Auckland, New Zealand.","category":"section"},{"location":"citing/citing/#Methods","page":"Citing","title":"Methods","text":"","category":"section"},{"location":"citing/citing/#single-trait-BayesA","page":"Citing","title":"single-trait BayesA","text":"Meuwissen T, Hayes B, Goddard M. 2001 Prediction of total genetic value using genome-wide dense marker maps. Genetics, 157:1819–1829.","category":"section"},{"location":"citing/citing/#single-trait-BayesB","page":"Citing","title":"single-trait BayesB","text":"Meuwissen T, Hayes B, Goddard M. 2001 Prediction of total genetic value using genome-wide dense marker maps. Genetics, 157:1819–1829.\nCheng H, Garrick D, Fernando R. 2015 A fast and efficient Gibbs sampler for BayesB in whole-genome analyses. Genet Sel Evol, 47:80.","category":"section"},{"location":"citing/citing/#single-trait-BayesC","page":"Citing","title":"single-trait BayesC","text":"Habier D, Fernando R, Kizilkaya K, Garrick D. 2011 Extension of the bayesian alphabet for genomic selection. BMC Bioinformatics, 12(1), 186.","category":"section"},{"location":"citing/citing/#single-trait-Bayesian-LASSO","page":"Citing","title":"single-trait Bayesian LASSO","text":"Gianola, D., & Fernando, R. L. (2019). A Multiple-Trait Bayesian Lasso for Genome-Enabled Analysis and Prediction of Complex Traits. Genetics, 214(2), genetics.302934.2019–331.","category":"section"},{"location":"citing/citing/#multi-trait-Bayesian-Alphabet","page":"Citing","title":"multi-trait Bayesian Alphabet","text":"Cheng H, Kizilkaya K, Zeng J, Garrick D, Fernando R 2018 Genomic Prediction from Multiple-Trait Bayesian Regression Methods Using Mixture Priors. Genetics, 209(1): 89-103.","category":"section"},{"location":"citing/citing/#single-step-Bayesian-Alphabet","page":"Citing","title":"single-step Bayesian Alphabet","text":"Fernando R, Dekkers J,Garrick D. 2015 A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses. Genetics Selection Evolution, 46(1), 50.\nFernando, R. L., Cheng, H., Golden, B. L., & Garrick, D. J. (2016). Computational strategies for alternative single-step Bayesian regression models with large numbers of genotyped and non-genotyped animals. Genetics Selection Evolution, 48(1), 96.","category":"section"},{"location":"citing/citing/#GWAS","page":"Citing","title":"GWAS","text":"Fernando R, Garrick D. 2013 Bayesian methods applied to GWAS. Methods Mol Biol., 1019:237–274.\nFernando, R., Toosi, A., Wolc, A., Garrick, D., & Dekkers, J. (2017). Application of Whole-Genome Prediction Methods for Genome-Wide Association Studies: A Bayesian Approach. Journal of Agricultural, Biological and Environmental Statistics, 57(4), 1–22.","category":"section"},{"location":"manual/benchmark/#Benchmark","page":"Benchmark","title":"Benchmark","text":"This page records a real benchmark run comparing runMCMC(...; fast_blocks=true) and runMCMC(...; fast_blocks=false) for the same target-scale question:\n\nN = 50,000 individuals\ntarget P = 2,000,000 markers\ntarget chain length L = 2000\n\nDate of run: February 26, 2026.","category":"section"},{"location":"manual/benchmark/#Goal","page":"Benchmark","title":"Goal","text":"Estimate wall-clock MCMC time for a single-trait BayesC run at target scale, and compare fast-block vs standard BayesC.","category":"section"},{"location":"manual/benchmark/#Environment","page":"Benchmark","title":"Environment","text":"Platform: UCD farm cluster (Slurm)\nJulia: 1.12.1\nModel: y1 = intercept + geno\nData: synthetic dense Float32 genotype matrix and synthetic phenotype\nSettings:\nmethod=\"BayesC\"\nmemory_guard=:warn\noutputEBV=false\noutput_heritability=false","category":"section"},{"location":"manual/benchmark/#Fast-Block-Benchmark-(fast_blockstrue)","page":"Benchmark","title":"Fast-Block Benchmark (fast_blocks=true)","text":"","category":"section"},{"location":"manual/benchmark/#Design","page":"Benchmark","title":"Design","text":"Slurm job: 30951323\nWarmup run before timed cases\nTimed grid:\nP ∈ {100,000, 200,000}\ninput chain_length ∈ {223, 446}\nREPS = 2\nBecause fast_blocks=true and N=50,000:\nblock_size = floor(sqrt(50000)) = 223\nouter iterations are floor(chain_length / 223) (1 or 2 in timed runs)\nExtrapolation:\nFor each P, fit t_mcmc = a + b * outer\nConvert target to outer iterations: floor(2000 / 223) = 8\nFit target time vs P using P = 100,000 and P = 200,000, then extrapolate to P = 2,000,000","category":"section"},{"location":"manual/benchmark/#Measured-t_mcmc-(seconds)","page":"Benchmark","title":"Measured t_mcmc (seconds)","text":"Rep P chain_length input outer t_mcmc\n1 100,000 223 1 76.515\n1 100,000 446 2 84.821\n1 200,000 223 1 147.150\n1 200,000 446 2 171.600\n2 100,000 223 1 70.930\n2 100,000 446 2 84.973\n2 200,000 223 1 142.255\n2 200,000 446 2 169.454","category":"section"},{"location":"manual/benchmark/#Extrapolated-Target-Time","page":"Benchmark","title":"Extrapolated Target Time","text":"SUMMARY_EST target_seconds = 3449.100\ntarget_hours = 0.958 (about 57.5 minutes)\nReplicate-based range: about 3274 to 3624 seconds (0.91 to 1.01 hours)","category":"section"},{"location":"manual/benchmark/#Standard-BayesC-Benchmark-(fast_blocksfalse)","page":"Benchmark","title":"Standard BayesC Benchmark (fast_blocks=false)","text":"","category":"section"},{"location":"manual/benchmark/#Design-2","page":"Benchmark","title":"Design","text":"Slurm job: 30951596\nWarmup run before timed cases\nTimed grid:\nP ∈ {100,000, 200,000}\nchain_length ∈ {2, 4}\nREPS = 2\nExtrapolation:\nFor each P, fit t_mcmc = a + b * chain_length\nPredict t_mcmc at chain_length = 2000\nFit those predicted times vs P and extrapolate to P = 2,000,000","category":"section"},{"location":"manual/benchmark/#Measured-t_mcmc-(seconds)-2","page":"Benchmark","title":"Measured t_mcmc (seconds)","text":"Rep P chain_length t_mcmc\n1 100,000 2 27.457\n1 100,000 4 40.214\n1 200,000 2 55.186\n1 200,000 4 107.764\n2 100,000 2 35.555\n2 100,000 4 53.252\n2 200,000 2 56.058\n2 200,000 4 109.762","category":"section"},{"location":"manual/benchmark/#Extrapolated-Target-Time-2","page":"Benchmark","title":"Extrapolated Target Time","text":"SUMMARY_EST target_seconds = 735340.060\ntarget_hours = 204.261 (about 8.5 days)\nReplicate-based range: about 701539 to 769141 seconds (194.9 to 213.7 hours)","category":"section"},{"location":"manual/benchmark/#Summary-Comparison","page":"Benchmark","title":"Summary Comparison","text":"Path Estimated MCMC time at target (N=50k, P=2M, L=2000)\nfast_blocks=true 3449 sec (0.958 h)\nfast_blocks=false 735340 sec (204.261 h)\n\nApproximate speedup from block mode in this benchmark setup: about 213x.","category":"section"},{"location":"manual/benchmark/#Notes-and-Interpretation","page":"Benchmark","title":"Notes and Interpretation","text":"These are empirical estimates from short-chain calibration runs, not exact guarantees.\nFor fast_blocks=true, chain interpretation is two-level (outer iterations + inner block repeats).\nThe two Slurm jobs landed on different CPU node types, so absolute times include some hardware variance.\nEven with that caveat, the gap between block and non-block is very large for this target-scale scenario.","category":"section"},{"location":"manual/memory_usage/#Memory-Usage-(BayesA/B/C-Marker-Paths)","page":"Memory Usage","title":"Memory Usage (BayesA/B/C Marker Paths)","text":"This page summarizes memory usage for JWAS marker samplers, with emphasis on the non-block path (fast_blocks=false) and how block mode changes memory requirements.","category":"section"},{"location":"manual/memory_usage/#Notation","page":"Memory Usage","title":"Notation","text":"N: number of records (nObs)\nP: number of markers (nMarkers)\nb: nominal block size\nB = ceil(P / b): number of blocks\ns_i: size of block i, with sum_i s_i = P\nt: bytes per stored value (t=4 for Float32, t=8 for Float64)\n\nMain allocations are created in GibbsMats(...) (src/1.JWAS/src/markers/tools4genotypes.jl).","category":"section"},{"location":"manual/memory_usage/#Non-Block-Mode-(fast_blocksfalse)","page":"Memory Usage","title":"Non-Block Mode (fast_blocks=false)","text":"","category":"section"},{"location":"manual/memory_usage/#What-is-stored","page":"Memory Usage","title":"What is stored","text":"X (genotype matrix): N x P\nxArray: column views of X (metadata only, no data copy)\nxpRinvx: length P\nxRinvArray:\naliases xArray when Rinv == ones(length(Rinv)) (no extra N x P copy)\nmaterializes [x .* Rinv for x in xArray] when weights are non-unit (extra N x P)\n\nThere are also marker-state vectors (alpha, beta, delta, posterior means, etc.) that scale as O(P) and are usually much smaller than N x P matrices.","category":"section"},{"location":"manual/memory_usage/#Approximate-memory-formulas","page":"Memory Usage","title":"Approximate memory formulas","text":"Unit weights (default when no weights column is used):  \n\nMem_nonblock_unit ~= t * (N*P + P) + O(P*t)\n\nNon-unit weights:  \n\nMem_nonblock_nonunit ~= t * (2*N*P + P) + O(P*t)\n\nInterpretation: non-block memory is dominated by one copy of X (unit weights) or two copies (non-unit weights).","category":"section"},{"location":"manual/memory_usage/#Block-Mode-Additions-(fast_blocks-!-false)","page":"Memory Usage","title":"Block Mode Additions (fast_blocks != false)","text":"Block mode keeps all non-block structures and adds:\n\nXArray: block views of X (metadata only)\nXpRinvX: per-block Gram matrices; total elements sum_i s_i^2 (approximately P*b for near-uniform blocks)\na temporary block RHS workspace of length up to block size (reused, not N*P scale)\n\nApproximate totals:\n\nUnit weights:  \n\nMem_block_unit ~= t * (N*P + sum_i s_i^2 + P) + O(P*t)\n\nNon-unit weights:  \n\nMem_block_nonunit ~= t * (2*N*P + sum_i s_i^2 + P) + O(P*t)","category":"section"},{"location":"manual/memory_usage/#Worked-Example-(N500,000,-P2,000,000)","page":"Memory Usage","title":"Worked Example (N=500,000, P=2,000,000)","text":"Assume fast_blocks=true, so b=floor(sqrt(N))=707.\n\nB = ceil(P/b) = 2,829\nsum_i s_i^2 = 1,413,937,788","category":"section"},{"location":"manual/memory_usage/#Original-non-block-version-(fast_blocksfalse)","page":"Memory Usage","title":"Original non-block version (fast_blocks=false)","text":"This is the base/original sampler memory footprint without block matrices.\n\nComponent Elements Float32 Float64\nX N*P = 1,000,000,000,000 4.00 TB (3.64 TiB) 8.00 TB (7.28 TiB)\nxRinvArray (unit weights) alias of xArray (no data copy) 0 0\nxRinvArray (non-unit weights) N*P 4.00 TB (3.64 TiB) 8.00 TB (7.28 TiB)\nxpRinvx P 8.0 MB (7.63 MiB) 16.0 MB (15.26 MiB)\n\nNon-block totals:\n\nNon-block case Float32 Float64\nUnit weights ~4.00 TB ~8.00 TB\nNon-unit weights ~8.00 TB ~16.00 TB","category":"section"},{"location":"manual/memory_usage/#Extra-objects-introduced-by-block-mode-(fast_blocks-!-false)","page":"Memory Usage","title":"Extra objects introduced by block mode (fast_blocks != false)","text":"Component sizes:\n\nComponent Elements Float32 Float64\nX N*P = 1,000,000,000,000 4.00 TB (3.64 TiB) 8.00 TB (7.28 TiB)\nxRinvArray (only non-unit weights) N*P 4.00 TB (3.64 TiB) 8.00 TB (7.28 TiB)\nXpRinvX (block mode) sum_i s_i^2 5.66 GB (5.27 GiB) 11.31 GB (10.53 GiB)\nxpRinvx P 8.0 MB (7.63 MiB) 16.0 MB (15.26 MiB)\n\nApproximate totals (dominated by N*P terms):\n\nMode Float32 Float64\nNon-block, unit weights ~4.00 TB ~8.00 TB\nNon-block, non-unit weights ~8.00 TB ~16.00 TB\nBlock, unit weights ~4.01 TB ~8.01 TB\nBlock, non-unit weights ~8.01 TB ~16.01 TB","category":"section"},{"location":"manual/memory_usage/#Practical-Takeaways","page":"Memory Usage","title":"Practical Takeaways","text":"At very large N and P, dense in-memory genotype matrices dominate memory in both non-block and block modes.\nNon-block mode is memory-cheapest when weights are unit (xRinvArray aliases xArray).\nCurrent block mode does not persist XRinvArray; extra memory is mainly XpRinvX (plus small reusable block workspaces).\nFor datasets like N=500k, P=2M, dense storage is multi-terabyte and typically requires a different data representation strategy.","category":"section"},{"location":"manual/sem/#structural-equation-model-(SEM)","page":"Structural Equation Model (SEM)","title":"structural equation model (SEM)","text":"This page is a single, layered guide to structural equation model (SEM) usage in JWAS. It is organized from practical setup to exact reference behavior to implementation-level notes.\n\nPages = [\"sem.md\"]\nDepth = 2","category":"section"},{"location":"manual/sem/#Quick-Index","page":"Structural Equation Model (SEM)","title":"Quick Index","text":"Beginner Quick Start\nReference\nDeep Technical Notes\nTroubleshooting","category":"section"},{"location":"manual/sem/#Beginner-Quick-Start","page":"Structural Equation Model (SEM)","title":"Beginner Quick Start","text":"Use SEM in JWAS when you have multiple phenotypes and a directed causal order among traits. JWAS samples structural coefficients during MCMC and reports direct, indirect, and overall marker effects.","category":"section"},{"location":"manual/sem/#Requirements-and-Constraints","page":"Structural Equation Model (SEM)","title":"Requirements and Constraints","text":"SEM is available in multi-trait analysis only.\ncausal_structure must be lower triangular.\nMatrix interpretation: column index affects row index.\nWhen SEM is enabled, JWAS enforces residual covariance constraint and disables missing phenotype imputation for identifiability.","category":"section"},{"location":"manual/sem/#End-to-End-Example","page":"Structural Equation Model (SEM)","title":"End-to-End Example","text":"using JWAS,DataFrames,CSV,Statistics,JWAS.Datasets\n\n# Step 1: Read demo data\nphenofile  = dataset(\"phenotypes.txt\", dataset_name=\"demo_7animals\")\npedfile    = dataset(\"pedigree.txt\", dataset_name=\"demo_7animals\")\ngenofile   = dataset(\"genotypes.txt\", dataset_name=\"demo_7animals\")\n\nphenotypes = CSV.read(phenofile,DataFrame,delim=',',header=true,missingstring=[\"NA\"])\npedigree   = get_pedigree(pedfile,separator=',',header=true)\ngenotypes  = get_genotypes(genofile,separator=',',method=\"BayesC\")\n\n# Step 2: Build model\nmodel_equation = \"y1 = intercept + x1 + x2 + x2*x3 + ID + dam + genotypes\n                  y2 = intercept + x1 + x2 + ID + genotypes\n                  y3 = intercept + x1 + ID + genotypes\"\nmodel = build_model(model_equation)\nset_covariate(model,\"x1\")\nset_random(model,\"x2\")\nset_random(model,\"ID dam\",pedigree)\n\n# Step 3: Define causal structure (trait1 -> trait2 and trait1 -> trait3)\nmy_structure = [0.0 0.0 0.0\n                1.0 0.0 0.0\n                1.0 0.0 0.0]\n\n# Step 4: Run SEM-enabled MCMC\nout = runMCMC(model,phenotypes; causal_structure=my_structure)","category":"section"},{"location":"manual/sem/#Expected-SEM-Outputs","page":"Structural Equation Model (SEM)","title":"Expected SEM Outputs","text":"After runMCMC finishes with causal_structure, JWAS writes SEM-specific files:\n\nstructure_coefficient_MCMC_samples.txt\nMCMC_samples_indirect_marker_effects_genotypes_<trait>.txt\nMCMC_samples_overall_marker_effects_genotypes_<trait>.txt\ndirect_marker_effects_genotypes.txt\nindirect_marker_effects_genotypes.txt\noverall_marker_effects_genotypes.txt\n\n<trait> corresponds to each phenotype in your multi-trait model (for example, y1, y2, y3).","category":"section"},{"location":"manual/sem/#Quick-Sanity-Checks","page":"Structural Equation Model (SEM)","title":"Quick Sanity Checks","text":"Confirm structure_coefficient_MCMC_samples.txt has one row per saved MCMC sample.\nConfirm indirect and overall marker-effect files exist for each trait.\nIf outputs are missing, first verify the genotype term name in model equations matches generated file names.","category":"section"},{"location":"manual/sem/#Reference","page":"Structural Equation Model (SEM)","title":"Reference","text":"","category":"section"},{"location":"manual/sem/#runMCMC(...;-causal_structure...)-Behavior","page":"Structural Equation Model (SEM)","title":"runMCMC(...; causal_structure=...) Behavior","text":"Item Behavior\nKeyword causal_structure\nDefault false (SEM disabled)\nExpected shape square matrix with dimension = number of traits\nSupported context multi-trait models only\nValue semantics non-zero entries define directed edges (column -> row)","category":"section"},{"location":"manual/sem/#Validation-and-Runtime-Side-Effects","page":"Structural Equation Model (SEM)","title":"Validation and Runtime Side Effects","text":"Condition Runtime behavior\ncausal_structure is provided in single-trait analysis error: SEM is multi-trait only\ncausal_structure is not lower triangular error: causal structure must be lower triangular\nSEM enabled missing_phenotypes is forced to false\nSEM enabled residual covariance constraint is enforced (mme.R.constraint = true)","category":"section"},{"location":"manual/sem/#causal_structure-Semantics","page":"Structural Equation Model (SEM)","title":"causal_structure Semantics","text":"For:\n\nmy_structure = [0.0 0.0 0.0\n                1.0 0.0 0.0\n                1.0 0.0 0.0]\n\nmy_structure[2,1] = 1.0 means trait 1 affects trait 2.\nmy_structure[3,1] = 1.0 means trait 1 affects trait 3.\nAll entries above diagonal must be zero.","category":"section"},{"location":"manual/sem/#Output-Files-(When-SEM-is-Enabled)","page":"Structural Equation Model (SEM)","title":"Output Files (When SEM is Enabled)","text":"File Meaning When generated\nstructure_coefficient_MCMC_samples.txt sampled structural coefficient matrix entries per saved iteration during MCMC sampling\nMCMC_samples_indirect_marker_effects_genotypes_<trait>.txt sampled indirect marker effects for trait post-MCMC processing\nMCMC_samples_overall_marker_effects_genotypes_<trait>.txt sampled direct + indirect marker effects for trait post-MCMC processing\ndirect_marker_effects_genotypes.txt posterior summary for direct marker effects post-MCMC processing\nindirect_marker_effects_genotypes.txt posterior summary for indirect marker effects post-MCMC processing\noverall_marker_effects_genotypes.txt posterior summary for overall marker effects post-MCMC processing","category":"section"},{"location":"manual/sem/#Compatibility-and-Limitations","page":"Structural Equation Model (SEM)","title":"Compatibility and Limitations","text":"Topic Current behavior\nTrait count SEM requires multi-trait setup\nMissing phenotypes disabled in SEM path\nResidual covariance constrained in SEM path\nMarker methods SEM post-processing expects marker-effect sample outputs for genotype terms\nNaming dependency output filenames include the genotype term name from model equations","category":"section"},{"location":"manual/sem/#Deep-Technical-Notes","page":"Structural Equation Model (SEM)","title":"Deep Technical Notes","text":"","category":"section"},{"location":"manual/sem/#Core-Objects-and-Notation","page":"Structural Equation Model (SEM)","title":"Core Objects and Notation","text":"In the SEM implementation:\n\nY is the sparse design built from observed trait values under the selected causal pattern.\nΛ (Lambda) is the structural coefficient matrix used to map direct and recursive relationships.\nΛy is the transformed phenotype vector under current SEM coefficients.\n\nKey implementation entry points:\n\nsrc/1.JWAS/src/structure_equation_model/SEM.jl\nSEM_setup, get_sparse_Y_FRM, get_Λ, tranform_lambda","category":"section"},{"location":"manual/sem/#Where-SEM-Is-Invoked-in-MCMC","page":"Structural Equation Model (SEM)","title":"Where SEM Is Invoked in MCMC","text":"At runtime:\n\nrunMCMC stores causal_structure and applies SEM constraints.\nMCMC_BayesianAlphabet calls SEM_setup(...) before sampling.\nEach iteration, get_Λ(...) samples structural coefficients and updates Λy/corrected residual vector.\nSaved SEM coefficient samples are written to structure_coefficient_MCMC_samples.txt.\n\nKey call sites:\n\nsrc/1.JWAS/src/JWAS.jl\nsrc/1.JWAS/src/MCMC/MCMC_BayesianAlphabet.jl","category":"section"},{"location":"manual/sem/#Post-MCMC-Marker-Effect-Pipeline","page":"Structural Equation Model (SEM)","title":"Post-MCMC Marker-Effect Pipeline","text":"After MCMC completion (SEM enabled):\n\ngenerate_indirect_marker_effect_sample(...) builds per-sample indirect marker effects.\ngenerate_overall_marker_effect_sample(...) combines direct and indirect effects.\ngenerate_marker_effect(..., effect_type) writes posterior summaries for direct/indirect/overall effects.\n\nThese steps currently rely on consistent genotype-term naming in output marker-effect sample files.","category":"section"},{"location":"manual/sem/#Current-Assumptions-and-Caveats","page":"Structural Equation Model (SEM)","title":"Current Assumptions and Caveats","text":"The SEM path assumes no missing-phenotype imputation during SEM sampling.\nLower-triangular causal structure is required for identifiability/order.\nFile-based post-processing is name-sensitive and depends on generated marker-effect filenames.","category":"section"},{"location":"manual/sem/#Troubleshooting","page":"Structural Equation Model (SEM)","title":"Troubleshooting","text":"","category":"section"},{"location":"manual/sem/#Lower-triangular-matrix-error","page":"Structural Equation Model (SEM)","title":"Lower-triangular matrix error","text":"Runtime message:\n\nThe causal structue needs to be a lower triangular matrix.\n\nCause:\n\ncausal_structure includes non-zero entries above the diagonal.\n\nFix:\n\nenforce lower-triangular form; keep only allowed directed edges where column affects row.","category":"section"},{"location":"manual/sem/#SEM-requested-in-single-trait-model","page":"Structural Equation Model (SEM)","title":"SEM requested in single-trait model","text":"Cause:\n\nSEM is enabled with only one trait.\n\nFix:\n\nuse SEM only in multi-trait runs.","category":"section"},{"location":"manual/sem/#Missing-indirect/overall-SEM-output-files","page":"Structural Equation Model (SEM)","title":"Missing indirect/overall SEM output files","text":"Cause:\n\ngenotype term name in model equations does not match expected marker-effect file naming.\n\nFix:\n\nkeep genotype term naming consistent (for example, genotypes in both model equation and output expectations).","category":"section"},{"location":"manual/sem/#Historical-regression-(issue-#162)","page":"Structural Equation Model (SEM)","title":"Historical regression (issue #162)","text":"runMCMC(...; causal_structure=...) previously failed from an internal field mismatch. This path is covered by unit regression test test/unit/test_sem_issue162.jl.","category":"section"},{"location":"manual/sem/#Related-Pages","page":"Structural Equation Model (SEM)","title":"Related Pages","text":"Workflow\nPublic API\nBlock BayesC","category":"section"},{"location":"FrequentlyAskedQuestions/FrequentlyAskedQuestions/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"link to Frequently Asked Questions wiki ","category":"section"},{"location":"log/#Development-Notes","page":"Development Notes","title":"Development Notes","text":"Historical feature notes have been moved out of the documentation tree.","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#Streaming-Genotype-Workflow:-A-Conceptual-Walkthrough","page":"Streaming Genotype Walkthrough","title":"Streaming Genotype Workflow: A Conceptual Walkthrough","text":"This page walks through the streaming genotype backend from start to finish, without code execution. For API details and constraints, see Streaming Genotype Backend and Handling Large Genotype Data.","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#1.-The-Problem","page":"Streaming Genotype Walkthrough","title":"1. The Problem","text":"At very large scale (e.g., N=500,000 individuals × P=2,000,000 markers), a dense genotype matrix in memory requires terabytes of RAM (~4 TB for Float32). The streaming backend avoids ever materializing that matrix by keeping genotypes on disk in a compact format and decoding only what is needed, one marker at a time.","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#2.-Input:-Text-Genotype-File","page":"Streaming Genotype Walkthrough","title":"2. Input: Text Genotype File","text":"You start with a text genotype file (e.g., CSV):\n\nFirst column: individual IDs\nRemaining columns: marker genotypes (0, 1, 2)\nMissing values: coded as 9.0 (or your chosen value)\n\nExample format:\n\nID,m1,m2,m3,...,m100\nind_001,0,1,2,...,1\nind_002,1,9,0,...,2   ← 9 = missing\n...","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#3.-One-Time-Conversion:-prepare_streaming_genotypes","page":"Streaming Genotype Walkthrough","title":"3. One-Time Conversion: prepare_streaming_genotypes","text":"This step reads the text file and writes a packed backend. It runs once, before any MCMC.\n\nWhat it does:\n\nChoose conversion path via conversion_mode:\n:lowmem (default): out-of-core conversion\n:dense: in-memory conversion for smaller files\n:auto: chooses dense when estimated N*P*4 <= auto_dense_max_bytes, else lowmem\nScan/process genotypes and compute marker statistics.\nQuality control: replace missing with column means; drop fixed loci and markers below the MAF threshold.\nCenter each marker column (optional).\nPrecompute per-marker x′x (for unit-weight BayesC).\nPack output:\nin low-memory mode: write temporary row-major spool, then transpose to marker-major\nin dense mode: pack directly from in-memory matrix\n\nFor large data, prefer :lowmem/:auto with appropriate tmpdir.\n\nOutput files:\n\nprefix.jgb2 — binary file containing 2-bit packed genotypes (0, 1, 2, missing) in marker-major layout; four individuals per byte\nprefix.meta — manifest (nObs, nMarkers, paths, etc.)\nprefix.obsid.txt, prefix.markerid.txt — individual and marker IDs\nprefix.mean.f32, prefix.xpRinvx.f32, prefix.afreq.f32 — precomputed values\n\nAfter QC, markers are stored in column order. For 50 individuals, each marker occupies ~13 bytes (4 bits per individual, rounded up).","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#4.-Loading:-get_genotypes(prefix;-storage:stream)","page":"Streaming Genotype Walkthrough","title":"4. Loading: get_genotypes(prefix; storage=:stream)","text":"Instead of loading a dense N×P matrix, this step:\n\nReads the manifest (the prefix.meta file: a small text file listing paths to the packed data and metadata such as nObs, nMarkers, stride_bytes, centered) and validates file sizes.\nOpens the .jgb2 file for reading.\nLoads metadata into memory: means, xpRinvx, allele frequencies, IDs.\nCreates a Genotypes struct with:\ngenotypes = empty matrix (no dense X)\nstream_backend = handle to the packed file and metadata\nstorage_mode = :stream","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#5.-MCMC:-Per-Iteration,-Per-Marker","page":"Streaming Genotype Walkthrough","title":"5. MCMC: Per Iteration, Per Marker","text":"For each MCMC iteration, BayesC updates markers one at a time.\n\nFor each marker j:\n\nDecode marker j into a temporary buffer:\nSeek to the marker's byte offset in the packed file.\nRead one packed row.\nDecode 2-bit codes → 0, 1, 2, or mean-imputed value.\nApply centering if the backend was built with center=true.\nWrite into a length-N buffer.\nUpdate Gibbs:\nUse the same formulas as dense mode.\nUse dot(buffer, yCorr) for x′y.\nUse precomputed xpRinvx[j] for x′x.\nSample δ, β, α.\nUpdate yCorr with yCorr += (old_α - new_α) * buffer.\nDiscard the buffer; it is reused for the next marker.\n\nSo the working set is O(N) per marker (one buffer plus yCorr, α, β, δ), not O(N×P).","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#6.-Initial-yCorr","page":"Streaming Genotype Walkthrough","title":"6. Initial yCorr","text":"The full computation yCorr = y - X*sol - X*α is done once, before the MCMC loop (using starting values for sol and α). After that, yCorr is maintained by incremental updates: each iteration adds/subtracts X*sol for fixed-effect updates, and each marker update applies yCorr += (old_α - new_α) * x_j in place.\n\nCode: src/1.JWAS/src/MCMC/MCMC_BayesianAlphabet.jl, lines 108–124 (inside MCMC_BayesianAlphabet, before the iteration loop).\n\nDense: yCorr = y - X*sol - X*α (matrix multiply).\n\nStreaming: streaming_mul_alpha! replaces X*α:\n\nLoop over markers j.\nFor each j with α[j] ≠ 0: decode marker j into a buffer, add α[j] * buffer into the output vector.\nNo dense X is ever formed.","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#7.-MVP-Constraints","page":"Streaming Genotype Walkthrough","title":"7. MVP Constraints","text":"Single-trait analysis only\nMethod: BayesC only\nfast_blocks=false only\nUnit residual weights only\nFloat32 only (double_precision=false)\nComplete genomic data only (no single-step)\nPhenotype IDs must match genotype IDs exactly and in the same order (no alignment)\noutputEBV and output_heritability are disabled","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#8.-End-to-End-Flow","page":"Streaming Genotype Walkthrough","title":"8. End-to-End Flow","text":"Text CSV → prepare_streaming_genotypes() → .jgb2 + metadata\n                    ↓\n        get_genotypes(prefix; storage=:stream)\n                    ↓\n        Genotypes struct (no dense X)\n                    ↓\n        runMCMC()\n                    ↓\nPer iteration:\n  Per marker j:\n    decode_marker!(buffer, backend, j) → buffer of length N\n    bayesabc_update_marker!(buffer, yCorr, α, β, δ, ...)","category":"section"},{"location":"manual/streaming_genotype_walkthrough/#9.-Memory-Comparison","page":"Streaming Genotype Walkthrough","title":"9. Memory Comparison","text":"Component Dense (N×P) Streaming\nGenotype matrix N×P×4 bytes 0\nPer-marker buffer 0 N×4 bytes\nxpRinvx P×4 bytes P×4 bytes\nTotal ~4×N×P ~O(N + P)\n\nAt large N and P, streaming keeps memory roughly constant in N×P, at the cost of decode and I/O per marker per iteration.","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: JWAS)\n\nJWAS is a well-documented software platform based on Julia and an interactive Jupyter notebook for analyses of general univariate and multivariate Bayesian mixed effects models.  These models are especially useful for, but not limited to, routine single-trait and multi-trait genomic prediction and genome-wide association studies using either complete or incomplete genomic data (\"single-step\" methods). Currently, JWAS provides broad scope of analyses, e.g., a wide collection of Bayesian methods for whole-genome analyses, including shrinkage estimation and variable selection methods. The features of JWAS include:\n\nUnivariate (single-trait) analysis\nMultivariate (multi-trait) analysis  \nNo limitations on fixed effects (e.g., herd, year, age, sex)\nRandom effects other than markers (e.g., litter, pen)                                  \nRandom effects using pedigree information\nAdditive genetic effects\nMaternal effects\nRandom permanent environmental effects  \nCorrelated residuals\t\t\nCorrelated random effects\nUnknown (or known) variance components\nUse of genomic information\nComplete genomic data                                      \t\t\nIncomplete genomic data (singe-step)","category":"section"},{"location":"#Supporting-and-Citing","page":"Home","title":"Supporting and Citing","text":"We hope the friendly user interface and fast computing speed of JWAS will provide power and convenience for users in both industry and academia to analyze large datasets. Further, as a well-documented open-source software tool, we hope JWAS will also be used by a group of active community members, who will contribute to the source code and help maintain the project. Junior scientists can understand and learn the methodologies for whole-genome analyses by using JWAS and reading the tutorials and source code.\n\nIf you would like to help support JWAS, please star the repository on the upper right corner here as such statistic will help to demonstrate the active involvement of the community. If you use JWAS for your research, teaching, or other activities, we would be grateful if you could cite our work following Citing.","category":"section"},{"location":"#The-trouble,-the-error-and-the-new-feature","page":"Home","title":"The trouble, the error and the new feature","text":"If you have trouble using JWAS, want new features or find errors in JWAS, please post it in our discussion group, open an issue, or contact <qtlcheng@ucdavis.edu>.","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#Theory","page":"Home","title":"Theory","text":"Pages = [\n  \"theory/theory.md\"\n]\nDepth = 3","category":"section"},{"location":"#Manual","page":"Home","title":"Manual","text":"Pages = [\n  \"manual/getstarted.md\",\n  \"manual/workflow.md\",\n  \"manual/block_bayesc.md\",\n  \"manual/memory_usage.md\",\n  \"manual/large_genotype_data_streaming.md\",\n  \"manual/streaming_genotype_backend.md\",\n  \"manual/streaming_genotype_walkthrough.md\",\n  \"manual/public.md\",\n  \"manual/internals.md\",\n]\nDepth = 3","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"Pages = [\n  \"examples/examples.md\"\n]\nDepth = 2","category":"section"}]
}
