var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#Internal-functions","page":"Internals","title":"Internal functions","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Documentation for JWAS.jl's internal (private) interface, which are not available to general users. These internal functions are small blocks that public function build on.","category":"page"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"<!–-","category":"page"},{"location":"manual/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"manual/internals/#Internal-interface","page":"Internals","title":"Internal interface","text":"","category":"section"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"Modules = [JWAS,JWAS.PedModule]\nOrder   = [:function, :type]","category":"page"},{"location":"manual/internals/#DataAPI.describe-Tuple{JWAS.MME}","page":"Internals","title":"DataAPI.describe","text":"describe(model::MME)\n\nPrint out model information.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.GWAS-Tuple{Any, Any, Vararg{AbstractString, N} where N}","page":"Internals","title":"JWAS.GWAS","text":"GWAS(model,map_file,marker_effects_file...;\n     window_size = \"1 Mb\",sliding_window = false,\n     GWAS = true, threshold = 0.001,\n     genetic_correlation = false,\n     header = true)\n\nrun genomic window-based GWAS\n\nMCMC samples of marker effects are stored in markereffectsfile with delimiter ','.\nmodel is either the model::MME used in analysis or the genotype cavariate matrix M::Array\nmap_file has the (sorted) marker position information with delimiter ','. If the map file is not provided, i.e., map_file=false, a fake map file will be generated with window_size markers in each 1 Mb window, and each 1 Mb window will be tested.\nIf two markereffectsfile are provided, and genetic_correlation = true, genomic correlation for each window is calculated.\nStatistics are computed for nonoverlapping windows of size window_size by default. If sliding_window = true, those for overlapping sliding windows are calculated.\nmap file format:\n\nmarkerID,chromosome,position\nm1,1,16977\nm2,1,434311\nm3,1,1025513\nm4,2,70350\nm5,2,101135\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.GWAS-Tuple{Any, Any}","page":"Internals","title":"JWAS.GWAS","text":"GWAS(marker_effects_file,model;header=true,window_size=100,threshold=0.001)\n\nrun genomic window-based GWAS without a map file\n\nMCMC samples of marker effects are stored in markereffectsfile with delimiter ','.\nwindow_size is either a constant (identical number of markers in each window) or an array of number of markers in each window\nmodel is either the model::MME used in analysis or the genotypic covariate matrix M::Array\nFile format:\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.GWAS-Tuple{Any}","page":"Internals","title":"JWAS.GWAS","text":"GWAS(marker_effects_file;header=true)\n\nCompute the model frequency for each marker (the probability the marker is included in the model) using samples of marker effects stored in markereffectsfile.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.SSBRrun","page":"Internals","title":"JWAS.SSBRrun","text":"(internal) Incomplete Genomic Data (Single-Step)\n\nreorder in A (pedigree) as ids for genotyped then non-genotyped inds\nimpute genotypes for non-genotyped individuals\nadd ϵ (imputation errors) and J as variables in data for non-genotyped inds\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.add_genotypes","page":"Internals","title":"JWAS.add_genotypes","text":"add_genotypes(mme::MME,M::Union{AbstractString,Array{Float64,2},Array{Float32,2},Array{Any,2},DataFrames.DataFrame},G=false;\n              header=false,rowID=false,separator=',',\n              center=true,G_is_marker_variance=false,df=4)\n\nGet marker informtion from a genotype file or an nxp Matrix M of genotypes (Array or DataFrame), where n is the number of individuals and p is the number of markers. This file/matrix needs to be column-wise sorted by marker positions.\nG is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes)\nIf a text file is provided, the file format should be:\nAnimal,marker1,marker2,marker3,marker4,marker5\nS1,1,0,1,1,1\nD1,2,0,2,2,1\nO1,1,2,0,1,0\nO3,0,0,2,1,1\nIf an nxp Matrix of genotypes (Array or DataFrame) is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nrowID is a vector of individual IDs, e.g.,rowID=[\"a1\",\"b2\",\"c1\"]; if it is omitted, IDs will be set to 1:n\nheader is a header vector such as [\"id\"; \"mrk1\"; \"mrk2\";...;\"mrkp\"]. If omitted, marker names will be set to 1:p\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.add_term-Tuple{Any, AbstractString}","page":"Internals","title":"JWAS.add_term","text":"add to model an extra term: imputation_residual\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.build_model","page":"Internals","title":"JWAS.build_model","text":"build_model(model_equations::AbstractString,R=false; df::AbstractFloat=4.0)\n\nBuild a model from model equations with the residual variance R. In Bayesian analysis, R is the mean for the prior assigned for the residual variance with degree of freedom df, defaulting to 4.0. If R is not provided, a value is calculated from responses (phenotypes).\nBy default, all variabels in modelequations are factors (categorical) and fixed. Set variables to be covariates (continuous) or random using functions `setcovariate()orset_random()`.\n\n#single-trait\nmodel_equations = \"BW = intercept + age + sex\"\nR               = 6.72\nmodels          = build_model(model_equations,R);\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex\n                   CW = intercept + litter\";\nR               = [6.72   24.84\n                   24.84  708.41]\nmodels          = build_model(model_equations,R);\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.center!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Internals","title":"JWAS.center!","text":"This function centers columns of the input matrix X by subtracting their means along each column. The function operates in-place by modifying the original matrix X.\n\nInput:\n- X::AbstractMatrix: a matrix to be centered\n\nOutput:\n- col_means::Vector: a vector of mean values for each column in the original matrix, computed before centering.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.getEBV-Tuple{Any, Any}","page":"Internals","title":"JWAS.getEBV","text":"getEBV(model::MME,traiti)\n\n(internal function) Get breeding values for individuals defined by outputEBV(), defaulting to all genotyped individuals. This function is used inside MCMC functions for one MCMC samples from posterior distributions. e.g., non-NNBayespartial (multi-classs Bayes) : y1=M1α1[1]+M2α2[1]+M3α3[1]                                            y2=M1α1[2]+M2α2[2]+M3α3[2]; NNBayespartial:     y1=M1α1[1]                      y2=M2α2[1]                      y3=M3*α3[1];\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.getMCMCinfo-Tuple{Any}","page":"Internals","title":"JWAS.getMCMCinfo","text":"getMCMCinfo(model::MME)\n\n(internal function) Print out MCMC information.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.getMME-Tuple{JWAS.MME, DataFrames.DataFrame}","page":"Internals","title":"JWAS.getMME","text":"Construct mixed model equations with\n\nincidence matrix: X      ; response        : ySparse; left-hand side  : mmeLhs ; right-hand side : mmeLhs ;\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.get_column_ref-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Internals","title":"JWAS.get_column_ref","text":"get_column_ref(X::Vector{T})\n\nTo obtain a vector of views (alias/pointer) for each column of the input matrix WITHOUT COPYING the underlying data. \ninput:  a matrix X\noutput: a vector containing views of each column of the input matrix X\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.get_genotypes","page":"Internals","title":"JWAS.get_genotypes","text":"get_genotypes(file::Union{AbstractString,Array{Float64,2},Array{Float32,2},Array{Any,2},DataFrames.DataFrame},G=false;\n              separator=',',header=true,rowID=false,\n              center=true,quality_control=false,\n              method = \"RR-BLUP\",Pi = 0.0,estimatePi = true,estimateScale=false,\n              G_is_marker_variance = false,df = 4.0)\n\nGet marker informtion from a genotype file/matrix. This file needs to be column-wise sorted by marker positions.\nIf a text file is provided, the file format should be:\nAnimal,marker1,marker2,marker3,marker4,marker5\nS1,1,0,1,1,1\nD1,2,0,2,2,1\nO1,1,2,0,1,0\nO3,0,0,2,1,1\nIf an nxp Matrix of genotypes (Array or DataFrame) is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nrowID is a vector of individual IDs, e.g.,rowID=[\"a1\",\"b2\",\"c1\"]; if it is omitted, IDs will be set to 1:n\nheader is a header vector such as [\"id\"; \"mrk1\"; \"mrk2\";...;\"mrkp\"]. If omitted, marker names will be set to 1:p\nIf quality_control=true, defaulting to true,\nMissing genotypes should be denoted as 9, and will be replaced by column means. Users can also impute missing genotypes before the analysis.\nMinor allele frequency MAF threshold, defaulting to 0.01, is uesd, and fixed loci are removed.\nG is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nAvailable methods include \"conventional (no markers)\", \"RR-BLUP\", \"BayesA\", \"BayesB\", \"BayesC\", \"Bayesian Lasso\", and \"GBLUP\".\nIn Bayesian variable selection methods, Pi for single-trait analyses is a number; Pi for multi-trait analyses is a dictionary such as Pi=Dict([1.0; 1.0]=>0.7,[1.0; 0.0]=>0.1,[0.0; 1.0]=>0.1,[0.0; 0.0]=>0.1), defaulting to all markers have effects (Pi = 0.0) in single-trait analysis and all markers have effects on all traits (Pi=Dict([1.0; 1.0]=>1.0,[0.0; 0.0]=>0.0)) in multi-trait analysis. Pi is estimated if estimatePi = true, , defaulting to false.\nScale parameter for prior of marker effect variance is estimated if estimateScale = true, defaulting to false.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.make_incidence_matrices-Tuple{Any, Any, Any}","page":"Internals","title":"JWAS.make_incidence_matrices","text":"make_incidence_matrices(mme,df_whole,train_index)\n\n(internal function) Make incidence matrices for effects involved in\n\ncalculation of EBV except marker covariates.\n\nBoth incidence matrices for non-missing observations (used in mixed model equations)\n\nand individuals of interest (output IDs) are obtained.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.mkDict-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Internals","title":"JWAS.mkDict","text":"mkDict(a::Vector{T}) where T <: Any\n\nGet column index in the incidence matrix for each level of a factor (categorical variable) \ninput:  a=[\"a1\",\"a4\",\"a1\",\"a2\"] \noutput: d=Dict(\"a2\" => 3, \"a1\" => 1, \"a4\" => 2), level_names=[\"a1\",\"a4\",\"a2\"]\n\nnote: enumerate(level_names) gives a list of tuples (index, element), reverse() to reverse (index,element) to (element,index)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.mkmat_incidence_factor-Tuple{Vector{T} where T, Vector{T} where T}","page":"Internals","title":"JWAS.mkmat_incidence_factor","text":"mkmatincidencefactor(yID::Vector, uID::Vector)     create an incidence matrix Z to reorder uID to yID by yID = ZuID.     input:          - yID: a vector containing the desired order of IDs         - uID: a vector containing the original order of IDs     output:          - Z: a sparse matrix representing the incidence relationship between yID and uID (yID = ZuID)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.outputEBV-Tuple{Any, Any}","page":"Internals","title":"JWAS.outputEBV","text":"outputEBV(model,IDs::Array)\n\nOutput estimated breeding values and prediction error variances for IDs.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.outputMCMCsamples-Tuple{JWAS.MME, Vararg{AbstractString, N} where N}","page":"Internals","title":"JWAS.outputMCMCsamples","text":"outputMCMCsamples(mme::MME,trmStrs::AbstractString...)\n\nGet MCMC samples for specific location parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.output_MCMC_samples","page":"Internals","title":"JWAS.output_MCMC_samples","text":"output_MCMC_samples(mme,vRes,G0,outfile=false)\n\n(internal function) Save MCMC samples every outputsamplesfrequency iterations to the text file.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.output_MCMC_samples_setup","page":"Internals","title":"JWAS.output_MCMC_samples_setup","text":"output_MCMC_samples_setup(mme,nIter,output_samples_frequency,file_name=\"MCMC_samples\")\n\n(internal function) Set up text files to save MCMC samples.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.output_location_parameters_samples-Tuple{JWAS.MME, Any, Any}","page":"Internals","title":"JWAS.output_location_parameters_samples","text":"output_location_parameters_samples(mme::MME,sol,outfile)\n\n(internal function) Save MCMC samples for location parameers\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.prediction_setup-Tuple{Any}","page":"Internals","title":"JWAS.prediction_setup","text":"prediction_setup(mme::MME,df::DataFrame)\n\n(internal function) Create incidence matrices for individuals of interest based on a usere-defined\n\nprediction equation, defaulting to genetic values including effects defined with genomic and pedigre information. For now, genomic data is always included.\n\nJ and ϵ are always included in single-step analysis (added in SSBR.jl)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.runMCMC-Tuple{JWAS.MME, Any}","page":"Internals","title":"JWAS.runMCMC","text":"runMCMC(model::MME,df::DataFrame;\n        #Data\n        heterogeneous_residuals           = false,\n        #MCMC\n        chain_length::Integer             = 100,\n        starting_value                    = false,\n        burnin::Integer                   = 0,\n        output_samples_frequency::Integer = chain_length>1000 ? div(chain_length,1000) : 1,\n        update_priors_frequency::Integer  = 0,\n        #Methods\n        estimate_variance               = true,\n        single_step_analysis            = false, #parameters for single-step analysis\n        pedigree                        = false, #parameters for single-step analysis\n        fitting_J_vector                = true,  #parameters for single-step analysis\n        categorical_trait               = false,\n        censored_trait                  = false,\n        causal_structure                = false,\n        mega_trait                      = false,\n        missing_phenotypes              = true,\n        constraint                      = false,\n        #Genomic Prediction\n        outputEBV                       = true,\n        output_heritability             = true,\n        prediction_equation             = false,\n        #MISC\n        seed                            = false,\n        printout_model_info             = true,\n        printout_frequency              = chain_length+1,\n        big_memory                      = false,\n        double_precision                = false,\n        ##MCMC samples (defaut to marker effects and hyperparametes (variance components))\n        output_folder                     = \"results\",\n        output_samples_for_all_parameters = false,\n        ##for deprecated JWAS\n        methods                         = \"conventional (no markers)\",\n        Pi                              = 0.0,\n        estimatePi                      = false,\n        estimateScale                   = false)\n\nRun MCMC for Bayesian Linear Mixed Models with or without estimation of variance components.\n\nMarkov chain Monte Carlo\nThe first burnin iterations are discarded at the beginning of a MCMC chain of length chain_length.\nSave MCMC samples every output_samples_frequency iterations, defaulting to chain_length/1000, to a folder output_folder, defaulting to results. MCMC samples for hyperparametes (variance componets) and marker effects are saved by default. MCMC samples for location parametes can be saved using function output_MCMC_samples(). Note that saving MCMC samples too frequently slows down the computation.\nThe starting_value can be provided as a vector for all location parameteres and marker effects, defaulting to 0.0s. The order of starting values for location parameters and marker effects should be the order of location parameters in the Mixed Model Equation for all traits (This can be obtained by getNames(model)) and then markers for all traits (all markers for trait 1 then all markers for trait 2...).\nMiscellaneous Options\nPriors are updated every update_priors_frequency iterations, defaulting to 0.\nMethods\nSingle step analysis is allowed if single_step_analysis = true and pedigree is provided.\nVariance components are estimated if estimate_variance=true, defaulting to true.\nMiscellaneous Options\nMissing phenotypes are allowed in multi-trait analysis with missing_phenotypes=true, defaulting to true.\nCatogorical Traits are allowed if categorical_trait=true, defaulting to false. Phenotypes should be coded as 1,2,3...\nCensored traits are allowed if the upper bounds are provided in censored_trait as an array, and lower bounds are provided as phenotypes.\nIf constraint=true, defaulting to false, constrain residual covariances between traits to be zeros.\nIf causal_structure is provided, e.g., causal_structure = [0.0 0.0 0.0;1.0 0.0 0.0;1.0 0.0 0.0] for trait 1 -> trait 2 and trait 1 -> trait 3 (column index affacts row index, and a lower triangular matrix is required), phenotypic causal networks will be incorporated using structure equation models.\nGenomic Prediction\nPredicted values for individuals of interest can be obtained based on a user-defined prediction equation prediction_equation, e.g., \"y1:animal + y1:age\".\nFor now, genomic data is always included. Genetic values including effects defined with genotype and pedigree information are returned if prediction_equation= false, defaulting to false.\nIndividual estimted genetic values and prediction error variances (PEVs) are returned if outputEBV=true, defaulting to true. Heritability and genetic\nvariances are returned if output_heritability=true, defaulting to true. Note that estimation of heritability is computaionally intensive.\nMiscellaneous Options\nPrint out the model information in REPL if printout_model_info=true; print out the monte carlo mean in REPL with printout_frequency, defaulting to false.\nIf seed, defaulting to false, is provided, a reproducible sequence of numbers will be generated for random number generation.\nIf big_memory=true, defaulting to false, a machine with  lots of memory is assumed which may speed up the analysis.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.set_covariate-Tuple{JWAS.MME, Vararg{AbstractString, N} where N}","page":"Internals","title":"JWAS.set_covariate","text":"set_covariate(model::MME,variables::AbstractString...)\n\nset variables as covariates; model is the output of function build_model().\n\n#After running build_model, variabels age and year can be set to be covariates as\nset_covariate(model,\"age\",\"year\")\n#or\nset_covariate(model,\"age year\")\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.set_random","page":"Internals","title":"JWAS.set_random","text":"set_random(mme::MME,randomStr::AbstractString,G;Vinv=0,names=[],df=4)\n\nset variables as random effects, defaulting to i.i.d effects, with variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nthe random effects are assumed to be i.i.d by default and it can be defined with any (inverse of) covariance structure Vinv with its index (row names) provided by names.\n\n#single-trait (i.i.d randome effects)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nG               = 0.6\nset_random(model,\"litter\",G)\n\n#multi-trait (i.i.d randome effects)\nmodel_equations = \"BW = intercept + litter + sex\n                   CW = intercept + litter + sex\"\nmodel           = build_model(model_equations,R);\nG               = [3.72  1.84\n                   1.84  3.41]\nset_random(model,\"litter\",G)\n\n#single-trait (randome effects with specific covariance structures)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nV               = [1.0  0.5 0.25\n                   0.5  1.0 0.5\n                   0.25 0.5 1.0]\nG               = 0.6\nset_random(model,\"litter\",G,Vinv=inv(V),names=[a1;a2;a3])\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.set_random-2","page":"Internals","title":"JWAS.set_random","text":"set_random(mme::MME,randomStr::AbstractString,ped::Pedigree, G;df=4)\n\nset variables as random polygenic effects with pedigree information ped. and variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\n\n#single-trait (example 1)\nmodel_equation  = \"y = intercept + age + animal\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = 1.6\nset_random(model,\"animal\", ped, G)\n\n#single-trait (example 2)\nmodel_equation  = \"y = intercept + age + animal + animal*age\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = [1.6   0.2\n                   0.2  1.0]\nset_random(model,\"animal animal*age\", ped,G)\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex + animal\n                   CW = intercept + age + sex + animal\"\nmodel           = build_model(model_equations,R);\nped             = get_pedigree(pedfile);\nG               = [6.72   2.84\n                   2.84  8.41]\nset_random(model,\"animal\",ped,G)\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#JWAS.solve-Tuple{JWAS.MME, DataFrames.DataFrame}","page":"Internals","title":"JWAS.solve","text":"solve(mme::MME,df::DataFrame;solver=\"default\",printout_frequency=100,tolerance = 0.000001,maxiter = 5000)\n\nSolve the mixed model equations (no marker information) without estimating variance components.\n\nAvailable solvers include default, Jacobi, Gauss-Seidel, and Gibbs sampler.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.transubstrarr-Tuple{Any}","page":"Internals","title":"JWAS.transubstrarr","text":"transubstrarr(vec)\n\n(internal function) Transpose a column vector of strings (vec' doesn't work here)\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.PedModule.get_info-Tuple{JWAS.PedModule.Pedigree}","page":"Internals","title":"JWAS.PedModule.get_info","text":"get_info(pedigree::Pedigree;Ai=false)\n\nPrint summary informtion from a pedigree object including number of individulas, sires. dams and founders. Return individual IDs, inverse of numerator relationship matrix, and inbreeding coefficients if Ai=true.\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/#JWAS.PedModule.get_pedigree-Tuple{Union{AbstractString, DataFrames.DataFrame}}","page":"Internals","title":"JWAS.PedModule.get_pedigree","text":"get_pedigree(pedfile::AbstractString;header=false,separator=',',missingstrings=[\"0\"])\n\nGet pedigree informtion from a pedigree file with header (defaulting to false) , separator (defaulting to ,) and missing values (defaulting to [\"0\"])\nPedigree file format:\n\na,0,0\nc,a,b\nd,a,c\n\n\n\n\n\n","category":"method"},{"location":"manual/internals/","page":"Internals","title":"Internals","text":"–>","category":"page"},{"location":"nnmm/Part1_introduction/#Part1.-introduction","page":"Part 1. introduction","title":"Part1. introduction","text":"","category":"section"},{"location":"nnmm/Part1_introduction/#.-Overview","page":"Part 1. introduction","title":"1. Overview","text":"","category":"section"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"The Mixed Effect Neural Networks (NN-MM) extend linear mixed model (\"MM\") to multilayer neural networks (\"NN\") by adding one middle layer between genotype layer and phenotypes layer. Nodes in the middle layer represent intermediate traits, e.g., the known intermediate omics features such as gene expression levels can be incorporated in the middle layer. These three sequential layers form a unified network. ","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"(Image: )","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"NN-MM allow any patterns of missing data in the middle layer, and missing data will be sampled. In below figure, for an individual, the gene expression levels of the first two genes are 0.9 and 0.1, respectively, and the gene expression level of the last gene is missing to be sampled. The missing patterns of gene expression levels can be different for different individuals.","category":"page"},{"location":"nnmm/Part1_introduction/#.-Extend-linear-mixed-model-to-multilayer-neural-networks","page":"Part 1. introduction","title":"2. Extend linear mixed model to multilayer neural networks","text":"","category":"section"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"Multiple independent single-trait mixed models are used to model the relationships between input layer (genotypes) and middle layer (intermediate traits). Activation functions in the neural network are used to approximate the linear/nonlinear relationships between middle layer (intermediate traits) and output layer (phenotypes). Missing values in the middle layer (intermediate traits) are sampled by Hamiltonian Monte Carlo based on the upstream genotype layer and downstream phenotype layer.","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"Details can be found in our publications:","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"Tianjing Zhao, Jian Zeng, and Hao Cheng. Extend mixed models to multilayer neural networks for genomic prediction including intermediate omics data, GENETICS, 2022; https://doi.org/10.1093/genetics/iyac034. \nTianjing Zhao, Rohan Fernando, and Hao Cheng. Interpretable artificial neural networks incorporating Bayesian alphabet models for genome-wide prediction and association studies, G3 Genes|Genomes|Genetics, 2021;  https://doi.org/10.1093/g3journal/jkab228","category":"page"},{"location":"nnmm/Part1_introduction/#.-Flexibility","page":"Part 1. introduction","title":"3. Flexibility","text":"","category":"section"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"NN-MM can fit fully-connected neural networks ((a),(b)), or partial-connected neural networks ((c),(d)). Also, the relationship between middle layer (intermediate traits) and output layer (phenotypes) can be based on activation functions ((a),(c)), or pre-defined by a user-defined function ((b),(d)).","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"(Image: )","category":"page"},{"location":"nnmm/Part1_introduction/#.-Multi-threaded-parallelism","page":"Part 1. introduction","title":"4. Multi-threaded parallelism","text":"","category":"section"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"By default, multiple single-trait models will be used to model the relationships between input layer (genotypes) and middle layer (intermediate traits). Multi-threaded parallelism will be used for parallel computing. The number of threads can be checked by running Threads.nthreads() in Julia. Usually, using multiple threads will be about 3 times faster than using a single thread.","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"The number of execution threads is controlled by using the -t/–threads command-line argument (requires at least Julia 1.5). ","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"For example, to start Julia with 4 threads:","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"julia --threads 4","category":"page"},{"location":"nnmm/Part1_introduction/","page":"Part 1. introduction","title":"Part 1. introduction","text":"If you're using Juno via IDE like Atom, all threads will be loaded automatically. ","category":"page"},{"location":"examples/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Examples","title":"Examples","text":"link to examples wiki ","category":"page"},{"location":"manual/getstarted/#Get-Started","page":"Get Started","title":"Get Started","text":"","category":"section"},{"location":"manual/getstarted/#Installation","page":"Get Started","title":"Installation","text":"","category":"section"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"To install julia, please go to the offical Julia website. Please see platform specific instructions if you have trouble installing Julia.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"To install the package, use the following command inside the Julia REPL (or IJulia Notebook):","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"Pkg.add(\"JWAS\")","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"To load the JWAS package, use the following command inside the Julia REPL (or IJulia Notebook):","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"using JWAS","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"The command Pkg.add(\"JWAS\") will add the registered official JWAS package and dependencies.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"To use the latest/beta features under development, run Pkg.add(PackageSpec(name=\"JWAS\", rev=\"master\")) to get the newest unofficial JWAS. Run Pkg.free(\"JWAS\") to go back to the official one.","category":"page"},{"location":"manual/getstarted/#Jupyter-Notebook","page":"Get Started","title":"Jupyter Notebook","text":"","category":"section"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"If you prefer “reproducible research”, an interactive Jupyter Notebook interface is available for Julia (and therefore JWAS). The Jupyter Notebook is an open-source web application for creating and sharing documents that contain live code, equations, visualizations and explanatory text. To install IJulia for Jupyter Notebook, please go to IJulia.","category":"page"},{"location":"manual/getstarted/#Docker","page":"Get Started","title":"Docker","text":"","category":"section"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"note: Jupyter Notebooks with JWAS via Docker\nDocker provides a straightforward way to install Jupyter Notebooks with JWAS.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"Install Docker from here for your platform.\nFrom a terminal (on Mac or Linux), run the command:","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"docker run -it --rm -p 8888:8888 qtlrocks/jwas-docker","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"This will start a Jupyter Notebook server listening for HTTP connections on port 8888 with a randomly generated authentication token. Examples for JWAS can be accessed from the notebook: notebooks/0_index.ipynb.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"The directories and files created within the Docker container will be lost when the container is stopped. To save your work on the host machine, a directory on the host machine can be mounted as a folder in the container with the -v option. After cd into your working directory on your local machine or a server, run the command","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"docker run -it --rm -p 8888:8888 -v `pwd`:/home/jovyan/work qtlrocks/jwas-docker","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"This command creates a Docker container with the folder /home/jovyan/work with the contents of pwd of the host machine. Files and directories that are in the folder pwd will not be lost when the container is stopped.  ","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"After running this command, it is expected to prompt something like","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"[I 10:41:54.774 NotebookApp] Writing notebook server cookie secret to /home/ubuntu/.local/share/jupyter/runtime/notebook_cookie_secret\n[I 10:41:54.920 NotebookApp] Serving notebooks from local directory: /home/ubuntu\n[I 10:41:54.920 NotebookApp] 0 active kernels\n[I 10:41:54.920 NotebookApp] The Jupyter Notebook is running at:\n[I 10:41:54.920 NotebookApp] http://0.0.0.0:8888/?token=75ad671f75b4c47be70591f46bec604997d8a9bd9dd51f0d\n[I 10:41:54.920 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n[C 10:41:54.921 NotebookApp]\n\n    Copy/paste this URL into your browser when you connect for the first time,\n    to login with a token:\n        http://0.0.0.0:8888/?token=75ad671f75b4c47be70591f46bec604997d8a9bd9dd51f0d","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"Then, open the url in an internet browser (IE, Firefox, Chrome, Safari, etc) if JWAS-docker is launched on your local machine.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"If you prefer running scripts using linux commands in Bash instead of Jupyter Notebook, please run the command","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"docker run -it --rm -v `pwd`:/home/jovyan/work qtlrocks/jwas-docker bash","category":"page"},{"location":"manual/getstarted/#Standalone-application","page":"Get Started","title":"Standalone application","text":"","category":"section"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"note: standalone application (no installation required)\nA fully self-contained application for JWAS (no installation required) will come out next year.","category":"page"},{"location":"manual/getstarted/#Access-documentation","page":"Get Started","title":"Access documentation","text":"","category":"section"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"warning: Warning\nPlease load the JWAS package at first.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"To show the basic information (README file) of JWAS in REPL or IJulia notebook using ?JWAS and press enter.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"For help on a specific function, type ? followed by its name, e.g. ?runMCMC and press enter in REPL or IJulia notebook.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"The full documentation is available here.","category":"page"},{"location":"manual/getstarted/#Run-your-analysis","page":"Get Started","title":"Run your analysis","text":"","category":"section"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"There are several ways to run your analysis.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"(1) The easiest way to run analysis in Julia is by starting an interactive session (REPL) by double-clicking the Julia executable or running julia from the command line (e.g., terminal) as","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"julia> 1+2\n3\n\njulia> 3*4\n12","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"To evaluate code written in a file script.jl in REPL, write and run","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"julia> include(\"script.jl\").","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"To exit the interactive session, type ^D – the control key together with the d key or type quit().","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"(2) To run code in a file non-interactively from the command line (e.g.,termial), you can give it as the first argument to the julia command:","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"julia script.jl","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"If you want to pass arguments to your script, run it as","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"julia script.jl arg1 arg2","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"where arguments arg1 and arg2 are passed to your script as ARGS[1] and ARGS[2] of type String. Please see julia docs for more options.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"(3) To run code in Jupyter Notebook, please see IJulia.","category":"page"},{"location":"manual/getstarted/","page":"Get Started","title":"Get Started","text":"(4) To run code in Jupyter Notebook via Docker, please see Docker.","category":"page"},{"location":"nnmm/Part2_NNMM/#Mixed-effect-neural-network:-Genotypes-Unobserved-intemediate-traits-Phenotyes","page":"Part 2. NNMM","title":"Mixed effect neural network: Genotypes -> Unobserved intemediate traits -> Phenotyes","text":"","category":"section"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"Tips: please center the phenotypes to have zero mean.","category":"page"},{"location":"nnmm/Part2_NNMM/#Example(a):-fully-connected-neural-networks,-all-intemediate-traits-are-unobserved","page":"Part 2. NNMM","title":"Example(a): fully-connected neural networks, all intemediate traits are unobserved","text":"","category":"section"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"nonlinear function (to define relationship between middle layer and phenotye): tanh (other supported activation functions: \"sigmoid\", \"relu\", \"leakyrelu\", \"linear\")\nnumber of nodes in the middle layer: 3\nBayesian model: multiple independent single-trait BayesC (to sample marker effects on intemediate traits). Note, to use multi-trait Bayesian Alphabet models, please set mega_trait=false in runMCMC() function.\nsample the unobserved intemediate traits in the middle layer: Hamiltonian Monte Carlo","category":"page"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"(Image: )","category":"page"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"# Step 1: Load packages\r\nusing JWAS,DataFrames,CSV,Statistics,JWAS.Datasets,Random\r\nRandom.seed!(123)\r\n\r\n# Step 2: Read data \r\nphenofile  = dataset(\"phenotypes.csv\") #get example data path\r\ngenofile   = dataset(\"genotypes.csv\")  #get example data path\r\n\r\nphenotypes = CSV.read(phenofile,DataFrame,delim = ',',header=true,missingstrings=[\"NA\"]) #read phenotypes (output layer)\r\ngenotypes  = get_genotypes(genofile,separator=',',method=\"BayesC\");                      #read genotypes  (input layer)\r\n\r\n\r\n# Step 3: Build Model Equations \r\nmodel_equation  =\"y1 = intercept + genotypes\"  #name of phenotypes is \"y1\" in the phenotypes data\r\n                                               #name of genotypes is \"genotypes\" (user-defined in the previous step)\r\n                                               #the single-trait mixed model used between input and each node in middle layer is: middle node = intercept + genotypes\r\nmodel = build_model(model_equation,\r\n\t\t    num_hidden_nodes=3,            #number of nodes in middle layer is 3\r\n\t\t    nonlinear_function=\"tanh\");    #tanh function is used to approximate relationship between middle layer and phenotype\r\n\r\n\r\n# Step 4: Run Analysis\r\nout=runMCMC(model,phenotypes,chain_length=5000); \r\n\r\n# Step 5: Check Accuruacy\r\nresults    = innerjoin(out[\"EBV_NonLinear\"], phenotypes, on = :ID) \r\naccuruacy  = cor(results[!,:EBV],results[!,:bv1])","category":"page"},{"location":"nnmm/Part2_NNMM/#Example-output-files","page":"Part 2. NNMM","title":"Example output files","text":"","category":"section"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"The i-th middle nodes will be named as \"trait name\"+\"i\". In our example, the observed trait is named \"y1\", and there are 3 middle nodes, so the middle nodes are named as \"y11\", \"y12\", and \"y13\", respectively.","category":"page"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"Below is a list of files containing estimates and standard deviations for variables of interest. ","category":"page"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"file name description\nEBV_NonLinear.txt estimated breeding values for observed trait\nEBV_y11.txt estimated breeding values for middle node 1\nEBV_y12.txt estimated breeding values for middle node 2\nEBV_y13.txt estimated breeding values for middle node 3\ngenetic_variance.txt estimated genetic variance-covariance of all middle nodes\nheritability.txt estimated heritability of all middle nodes\nlocation_parameters.txt estimated bias of all middle nodes\nneuralnetworksbiasandweights.txt. estimated bias of phenotypes and weights between middle nodes and phenotypes\npi_genotypes.txt estimated pi of all middle nodes\nmarkereffectsgenotypes.txt estimated marker effects of all middle nodes\nresidual_variance.txt estimated residual variance-covariance for all middle nodes","category":"page"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"Below is a list of files containing MCMC samples for variables of interest. ","category":"page"},{"location":"nnmm/Part2_NNMM/","page":"Part 2. NNMM","title":"Part 2. NNMM","text":"file name description\nMCMCsamplesEBV_NonLinear.txt MCMC samples from the posterior distribution of breeding values for phenotypes\nMCMCsamplesEBV_y11.txt MCMC samples from the posterior distribution of breeding values for middle node 1\nMCMCsamplesEBV_y12.txt MCMC samples from the posterior distribution of breeding values for middle node 2\nMCMCsamplesEBV_y13.txt MCMC samples from the posterior distribution of breeding values for middle node 3\nMCMCsamplesgenetic_variance.txt MCMC samples from the posterior distribution of genetic variance-covariance for all middle nodes\nMCMCsamplesheritability.txt MCMC samples from the posterior distribution of heritability for all middle nodes\nMCMCsamplesmarkereffectsgenotypes_y11 MCMC samples from the posterior distribution of marker effects for middle node 1\nMCMCsamplesmarkereffectsgenotypes_y12 MCMC samples from the posterior distribution of marker effects for middle node 2\nMCMCsamplesmarkereffectsgenotypes_y13 MCMC samples from the posterior distribution of marker effects for middle node 3\nMCMCsamplesmarkereffectsvariances_genotypes.txt MCMC samples from the posterior distribution of marker effect variance for all middle nodes\nMCMCsamplesneuralnetworksbiasandweights.txt. MCMC samples from the posterior distribution of bias of observed trait and weights between middle nodes and phenotypes\nMCMCsamplespi_genotypes.txt MCMC samples from the posterior distribution of pi for all middle nodes\nMCMCsamplesresidual_variance.txt MCMC samples from the posterior distribution of residual variance-covariance for all middle nodes","category":"page"},{"location":"theory/theory/#Some-Theory-in-JWAS","page":"Some Theory","title":"Some Theory in JWAS","text":"","category":"section"},{"location":"theory/theory/#A-Table-for-Bayesian-Linear-Mixed-Models-(BLMM)","page":"Some Theory","title":"A Table for Bayesian Linear Mixed Models (BLMM)","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"(Image: BLMM)","category":"page"},{"location":"theory/theory/#Models","page":"Some Theory","title":"Models","text":"","category":"section"},{"location":"theory/theory/#Complete-Genomic-Data","page":"Some Theory","title":"Complete Genomic Data","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"The general form of the multivariate (univariate) mixed effects model for individual i from n individuals with complete genomic data in JWAS is","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"\nmathbfy_i\n =sum_j=1^p_bX_ijmathbfb_j+sum_k=1^p_uZ_ikmathbfu_k\n +sum_l=1^pM_ilboldsymbolalpha_l+mathbfe_i(1)","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"where mathbfy_i is a vector of phenotypes of t traits for individual i; X_ij is the incidence matrix covariate corresponding to the jth fixed effect for individual i; mathbfb_j is a vector of jth fixed effects for the t traits; Z_ik is the incidence matrix covariate corresponding to the kth random effect for individual i; boldsymbolu_k is a vector of the kth random effects of t traits; M_il is the genotype covariate at locus l for individual i, p is the number of genotyped loci (each coded as 0,1,2), boldsymbolalpha_l is a vector of allele substitution effects or marker effects of t traits for locus j, and mathbfe_i is the vector of random residual effects of t traits for individual i. The JWAS implementation of this model involves missing phenotypes being imputed at each iteration of MCMC \\cite{sorensenGianolaBook} so that all individuals have observations for all traits. Note that when the number of traits t=1, the general form above simplifies to the single-trait  mixed effects model, and all vectors of effects in equation (1) become scalars.","category":"page"},{"location":"theory/theory/#Incomplete-Genomic-Data","page":"Some Theory","title":"Incomplete Genomic Data","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"The general form of the multivariate (univariate) mixed effects model with incomplete genomic data (\"single-step\" methods) for non-genotyped individuals is","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"mathbfy_i\n=sum_j=1^p_bX_ijmathbfb_j+sum_k=1^p_uZ_ikmathbfu_k+\nsum_l=1^phatM_ilboldsymbolalpha_l+sum_m=1^p_epsilonZ_nimboldsymbolepsilon_m+boldsymbole_i (2)","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"where mathbfy_i is a vector of phenotypes of t traits for non-genotyped individual i;  hatM_il is the imputed genotype covariate at locus l for non-genotyped individual i, Z_nim is the incidence matrix covariate corresponding to the mth imputation residual for individual i and boldsymbolepsilon_i is a vector of imputation residuals. W_im is the incidence matrix covariate corresponding to the mth random effect for individual i. That vector of imputation residuals, boldsymbolepsilon=beginbmatrixboldsymbolepsilon_1^T  boldsymbolepsilon_2^T  ldots  endbmatrix^T, are a priori assumed to be Nleft(0(mathbfA_nn-mathbfA_ngmathbfA_gg^-1mathbfA_gn)otimesmathbfG_gright), where mathbfA_nn is the partition of the numerator relationship matrix  mathbfA that corresponds to non-genotyped individuals, mathbfA_ng or its transpose mathbfA_gn are partitions of mathbfA corresponding to relationships between non-genotyped and genotyped individuals or vice versa,  mathbfA_gg is the  partition of mathbfA that corresponds to genotyped animals, and mathbfG_g is the additive genetic covariance matrix. All the other variables are the same as in equation (1).","category":"page"},{"location":"theory/theory/#Priors","page":"Some Theory","title":"Priors","text":"","category":"section"},{"location":"theory/theory/#Priors-for-effects-other-than-markers","page":"Some Theory","title":"Priors for effects other than markers","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"The fixed effects are assigned flat priors. The vector of random effects, mathbfu=beginbmatrixmathbfu_1^T  mathbfu_2^T  ldots  mathbfu_p_2^Tendbmatrix^T, are a priori assumed to be Nleft(0mathbfAotimesmathbfGright) with various options for mathbfA. For example, mathbfA could be an identity matrix if boldsymbolu_k is assumed to be independently and identically distributed. mathbfA can be  the numerator relationship matrix, when boldsymbolu is a vector of polygenic effects and mathbfG represents the additive-genetic variance not explained by molecular markers. Note that boldsymbolu can also be a concatenation of vectors of different types of random effects, such as litter, pen, polygenic and maternal effects. The vector boldsymbole_i of residuals are a priori assumed to be independently and identically following multivariate normal distributions with null mean and covariance matrix mathbfR, which in turn is a priori assumed to have an inverse Wishart prior distribution, W_t^-1left(mathbfS_enu_eright). Note that when number of traits t=1, the priors for mathbfG and mathbfR in single-trait analyses follow scaled inverted chi-square distributions.","category":"page"},{"location":"theory/theory/#Priors-for-marker-effects","page":"Some Theory","title":"Priors for marker effects","text":"","category":"section"},{"location":"theory/theory/#single-trait-BayesA","page":"Some Theory","title":"single-trait BayesA","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"The prior assumption is that marker effects have identical and independent univariate-t distributions each with a null mean, scale parameter S^2_alpha and nu degrees of freedom. This is equivalent to assuming that the marker effect at locus i has a univariate normal with null mean and unknown, locus-specific variance sigma^2_i, which in turn is assigned a scaled inverse chi-square prior with scale parameter S^2_alpha and nu_alpha degrees of freedom.","category":"page"},{"location":"theory/theory/#single-trait-BayesB","page":"Some Theory","title":"single-trait BayesB","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"In BayesB, the prior assumption is that marker effects have identical and independent mixture distributions, where each has a point mass at zero with probability pi and a univariate-t distribution with probability 1-pi having a null mean, scale parameter S^2_alpha and nu degrees of freedom. Thus, BayesA is a special case of BayesB with pi=0. Further, as in BayesA, the t-distribution in BayesB is equivalent to a univariate normal with null mean and unknown, locus-specific variance, which in turn is assigned a scaled inverse chi-square prior with scale parameter S^2_alpha and nu_alpha degrees of freedom. (A fast and efficient Gibbs sampler was implemented for BayesB in JWAS.)","category":"page"},{"location":"theory/theory/#single-trait-BayesC-and-BayesC\\pi","page":"Some Theory","title":"single-trait BayesC and BayesCpi","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"In BayesC, the prior assumption is that marker effects have identical and independent mixture distributions, where each has a point mass at zero with probability pi and a univariate-normal distribution with probability 1-pi having a null mean and variance sigma^2_alpha, which in turn has a scaled inverse chi-square prior with scale parameter S^2_alpha and nu_alpha degrees of freedom. In addition to the above assumptions, in BayesC pi, pi is treated as unknown with a uniform prior.","category":"page"},{"location":"theory/theory/#multiple-trait-Bayesian-Alphabet","page":"Some Theory","title":"multiple-trait Bayesian Alphabet","text":"","category":"section"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"In multi-trait BayesCPi, the prior for alpha_lk, the marker effect of trait k for locus l, is a mixture with a point mass at zero and a univariate normal distribution conditional on sigma_k^2:","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"alpha_lkmidpi_ksigma_k^2  begincases\nsim Nleft(0sigma_k^2right)   probability(1-pi_k)\n0   probabilitypi_k\nendcases","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"and the covariance between effects for traits k and k at the same locus, i.e., alpha_lk and alpha_lk^ is","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"covleft(alpha_lkalpha_lk^midsigma_kk^right)=begincases\nsigma_kk^  ifbothalpha_lkneq0andalpha_lk^neq0\n0  otherwise\nendcases","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"The vector of marker effects at a particular locus boldsymbolalpha_l is written as boldsymbolalpha_l=boldsymbolD_lboldsymbolbeta_l, where boldsymbolD_l is a diagonal matrix with elements diagleft(boldsymbolD_lright)=boldsymboldelta_l=left(delta_l1delta_l2delta_l3ldotsdelta_ltright), where delta_lk is an indicator variable indicating whether the marker effect of locus l for trait k is zero or non-zero, and the vector boldsymbolbeta_l follows a multivariate normal distribution with null mean and covariance matrix boldsymbolG. The covariance matrix boldsymbolG is a priori assumed to follow an inverse Wishart distribution, W_t^-1left(mathbfS_betanu_betaright).","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"In the most general case, any marker effect might be zero for any possible combination of t traits resulting in 2^t possible combinations of boldsymboldelta_l. For example, in a t=2 trait model, there are 2^t=4 combinations for  boldsymboldelta_l: (00), (01), (10), (11). Suppose in general we use numerical labels \"1\", \"2\",ldots, \"l\" for the 2^t possible outcomes for  boldsymboldelta_l, then the prior for  boldsymboldelta_l is a categorical distribution","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"pleft(boldsymboldelta_l=iright)= Pi_1Ileft(boldsymboldelta_l=1right)+Pi_2Ileft(boldsymboldelta_l=2right)++Pi_lIleft(boldsymboldelta_l=lright)","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"where sum_i=1^lPi_i=1 with Pi_i being the prior probability that the vector boldsymboldelta_l corresponds to the vector labelled i. A Dirichlet distribution with all parameters equal to one, i.e., a uniform distribution, can be used for the prior for boldsymbolPi=left(Pi_1Pi_2Pi_lright).   ","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"The differences in multi-trait BayesB method is that the prior for boldsymbolbeta_l is a multivariate t distribution, rather than a multivariate normal distribution. This is equivalent to assuming boldsymbolbeta_l has a multivariate normal distribution with null mean and locus-specific covariance matrix boldsymbolG_l, which is assigned an inverse Wishart prior, W_t^-1left(mathbfS_betanu_betaright). Multi-trait BayesA method is a special case of multi-trait BayesB method where boldsymboldelta_l is always a vector of ones.","category":"page"},{"location":"theory/theory/","page":"Some Theory","title":"Some Theory","text":"referencesMeuwissen T, Hayes B, Goddard M. Prediction of total genetic value using genome-wide dense marker maps. Genetics, 2001,157:1819–1829.\nFernando R, Garrick D. Bayesian methods applied to GWAS. Methods Mol Biol. 2013, 1019:237–274.\nCheng H, Garrick D, Fernando R. A fast and efficient Gibbs sampler for BayesB in whole- genome analyses. Genetics Selection Evolution, 2015, 47:80.\nFernando R, Dekkers J, Garrick D. A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses. Genetics Selection Evolution, 2015, 46(1), 50.\nFernando R, Cheng H, Golden B, Garrick D.. Computational strategies for alternative single-step Bayesian regression models with large numbers of genotyped and non-genotyped animals. Genetics Selection Evolution, 2016, 48(1), 96.\nCheng H, Kizilkaya K, Zeng J, Garrick D, Fernando R. Genomic Prediction from Multiple-trait Bayesian Regression Methods using Mixture Priors. Genetics. 2018, 209(1).","category":"page"},{"location":"manual/workflow/#Workflow","page":"Workflow","title":"Workflow","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"A step by step workflow for how to run JWAS is shown in this section. The workflow below is used to demonstrate a three-trait Bayesian linear mixed model fitting fixed effects (x1, x3), random effects (x2), direct genetic effects (ID), maternal genetic effects (dam) and genomic information.","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Pages = [\n  \"workflow.md\"\n]\nDepth = 2","category":"page"},{"location":"manual/workflow/#Available-Models","page":"Workflow","title":"Available Models","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Given the data and model equations, several different types of models are available in JWAS as shown below. In the table below, \"X\" denotes the type of available data, and \"Y<=A\" denotes that Y individuals is a subset of A individuals.  ","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Linear Mixed Models (LMM) phenotypes (Y) pedigree (A) genotypes (G) notes\nConventional LMM X   \nPedigree-based LMM X X  Y<=A\nComplete Genomic LMM X optional X Y<=G\nIncomplete Genomic LMM X X X Y<=A,G<=A","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"note: Note\nIncomplete Genomic LMM is also called \"single-step\" methods in animal breeding.\nPedigree information may be used in Complete Genomic LMM for extra polygenic effects to account for genetic variance not explained by the genomic data (e.g., SNPs).\nPedigree-based LMM (none of the individuals in the pedigree are genotyped) and Complete Genomic LMM (all individuals in the pedigree are genotyped) are special cases of Incomplete Genomic LMM (part of the individuals in the pedigree are genotyped).","category":"page"},{"location":"manual/workflow/#Get-Data-Ready","page":"Workflow","title":"Get Data Ready","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"By default, input data files are comma-separated values (CSV) files, where each line of the file consists of one or more fields, separated by commas. Other field separators such as space (' ') or tab ('\\t') can be used if you supply the keyword argument, e.g, CSV.read(...,delim='\\t') or add_genotypes(...,separator='\\t')","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Click on the buttons inside the tabbed menu to see the data:","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<style>\nbody {font-family: Arial;}\n\n/* Style the tab */\n.tab {\n    overflow: hidden;\n    border: 1px solid #ccc;\n    background-color: #f1f1f1;\n}\n\n/* Style the buttons inside the tab */\n.tab button {\n    background-color: inherit;\n    float: left;\n    border: none;\n    outline: none;\n    cursor: pointer;\n    padding: 14px 16px;\n    transition: 0.3s;\n    font-size: 17px;\n}\n\n/* Change background color of buttons on hover */\n.tab button:hover {\n    background-color: #ddd;\n}\n\n/* Create an active/current tablink class */\n.tab button.active {\n    background-color: #ccc;\n}\n\n/* Style the tab content */\n.tabcontent {\n    display: none;\n    padding: 6px 12px;\n    border: 1px solid #ccc;\n    border-top: none;\n}\n</style>\n</head>\n<body>\n\n<div class=\"tab\">\n  <button class=\"tablinks\" onclick=\"openCity(event, 'phenotypes')\">phenotypes.txt</button>\n  <button class=\"tablinks\" onclick=\"openCity(event, 'pedigree')\">pedigree.txt</button>\n  <button class=\"tablinks\" onclick=\"openCity(event, 'genotypes')\">genotypes.txt</button>\n  <button class=\"tablinks\" onclick=\"openCity(event, 'map file')\">map.txt</button>\n</div>\n\n<div id=\"phenotypes\" class=\"tabcontent\">\n<p>ID,y1,y2,y3,x1,x2,x3,dam</p>\n<p>a1,-0.06,3.58,-1.18,0.9,2,m,NA</p>\n<p>a2,-0.6,4.9,0.88,0.3,1,f,NA</p>\n<p>a3,-2.07,3.19,0.73,0.7,2,f,NA</p>\n<p>a4,-2.63,6.97,-0.83,0.6,1,m,a2</p>\n<p>a5,2.31,3.5,-1.52,0.4,2,m,a2</p>\n<p>a6,0.93,4.87,-0.01,05,2,f,a3</p>\n<p>a7,-0.69,3.1,-1.47,0.5,2,f,a3</p>\n<p>a8,-4.69,7.31,-1.09,0.3,2,m,a6</p>\n<p>a9,-2.81,7.18,0.76,0.4,2,m,a6</p>\n<p>a10,1.92,1.78,-0.88,0.2,1,m,a7</p>\n</div>\n\n<div id=\"pedigree\" class=\"tabcontent\">\n<p>ID,Sire,Dam</p>\n<p>a1,0,0</p>\n<p>a2,0,0</p>\n<p>a3,0,0</p>\n<p>a4,a1,a2</p>\n<p>a5,a1,a2</p>\n<p>a6,a1,a3</p>\n<p>a7,a1,a3</p>\n<p>a8,a4,a6</p>\n<p>a9,a4,a6</p>\n<p>a10,a5,a7</p>\n</div>\n\n<div id=\"genotypes\" class=\"tabcontent\">\n<p>ID,m1,m2,m3,m4,m5</p>\n<p>a1,1,2,1,1,0</p>\n<p>a2,2,1,1,1,1</p>\n<p>a3,1,1,0,1,1</p>\n<p>a4,2,2,0,1,0</p>\n<p>a5,1,1,2,1,1</p>\n<p>a6,2,1,0,0,0</p>\n<p>a7,0,2,1,2,1</p>\n<p>a8,2,2,0,0,0</p>\n<p>a9,2,1,0,1,0</p>\n<p>a10,0,2,2,2,1</p>\n</div>\n\n<div id=\"map file\" class=\"tabcontent\">\n<p>markerID,chromosome,position</p>\n<p>m1,1,16977</p>\n<p>m2,1,434311</p>\n<p>m3,1,1025513</p>\n<p>m4,2,70350</p>\n<p>m5,2,101135</p>\n</div>\n\n\n<script>\nfunction openCity(evt, cityName) {\n    var i, tabcontent, tablinks;\n    tabcontent = document.getElementsByClassName(\"tabcontent\");\n    for (i = 0; i < tabcontent.length; i++) {\n        tabcontent[i].style.display = \"none\";\n    }\n    tablinks = document.getElementsByClassName(\"tablinks\");\n    for (i = 0; i < tablinks.length; i++) {\n        tablinks[i].className = tablinks[i].className.replace(\" active\", \"\");\n    }\n    document.getElementById(cityName).style.display = \"block\";\n    evt.currentTarget.className += \" active\";\n}\n</script>\n</body>","category":"page"},{"location":"manual/workflow/#Step-1:-Load-Packages","page":"Workflow","title":"Step 1: Load Packages","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"using JWAS,CSV,DataFrames","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"The JWAS package is loaded, as well as the CSV and DataFrame packages for reading text files.","category":"page"},{"location":"manual/workflow/#Step-2:-Read-Data","page":"Workflow","title":"Step 2: Read Data","text":"","category":"section"},{"location":"manual/workflow/#Read-Phenotypic-Data","page":"Workflow","title":"Read Phenotypic Data","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"phenotypes = CSV.read(\"phenotypes.txt\",DataFrame,delim = ',',header=true,,missingstrings=[\"NA\"])\nfirst(phenotypes)","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"output:","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"6×8 DataFrames.DataFrame\n│ Row │ ID │ y1    │ y2   │ y3    │ x1  │ x2 │ x3 │ dam       │\n├─────┼────┼───────┼──────┼───────┼─────┼────┼────┼───────────┤\n│ 1   │ a1 │ -0.06 │ 3.58 │ -1.18 │ 0.9 │ 2  │ m  │ missing   │\n│ 2   │ a2 │ -0.6  │ 4.9  │ 0.88  │ 0.3 │ 1  │ f  │ missing   │\n│ 3   │ a3 │ -2.07 │ 3.19 │ 0.73  │ 0.7 │ 2  │ f  │ missing   │\n│ 4   │ a4 │ -2.63 │ 6.97 │ -0.83 │ 0.6 │ 1  │ m  │ a2        │\n│ 5   │ a5 │ 2.31  │ 3.5  │ -1.52 │ 0.4 │ 2  │ m  │ a2        │\n│ 6   │ a6 │ 0.93  │ 4.87 │ -0.01 │ 5.0 │ 2  │ f  │ a3        │","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"The phenotypic data is read on line 1. On line 2, the first several rows of the phenotypic data are shown.","category":"page"},{"location":"manual/workflow/#Read-Pedigree-Data","page":"Workflow","title":"Read Pedigree Data","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"pedigree   = get_pedigree(\"pedigree.txt\",separator=\",\",header=true)","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"link to documentation for get_pedigree","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"The pedigree data is read on line 1.","category":"page"},{"location":"manual/workflow/#Read-Genomic-Data","page":"Workflow","title":"Read Genomic Data","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"genotypes  = get_genotypes(\"genotypes.txt\",G,method=\"BayesC\",separator=\",\",header=true) #G is optional","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"link to documentation for get_genotypes","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"On line 1, the genomic information is read on line 1 with the genotype file.  and variance G (a 3x3 matrix). In Bayesian analysis, the G is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).","category":"page"},{"location":"manual/workflow/#Step-3:-Build-Model-Equations","page":"Workflow","title":"Step 3: Build Model Equations","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"model_equation = \"y1 = intercept + x1 + x3 + ID + dam + genotypes\n                  y2 = intercept + x1 + x2 + x3 + ID + genotypes\n                  y3 = intercept + x1 + x1*x3 + x2 + ID + genotypes\"\nmodel=build_model(model_equation,R) #R is optional","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"link to documentation for build_model","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"The model equation for a 3-trait analysis is defined on the first 3 lines.","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"The effects fitted in the model for trait y1 are the intercept, x1, x3, direct genetic effects (ID), maternal genetic effects (dam), and molecular marker effects (genotypes).\nThe effects fitted in the model for trait y2 are the intercept, x1, x2, x3, direct genetic effects (ID), and molecular marker effects (genotypes).\nThe effects fitted in the model for trait y3 are the intercept, x1, the interaction between x1 and x3, x2, direct genetic effects (ID), and , and molecular marker effects (genotypes).","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"On the last line, the model is built given the model equation and residual variance R (a 3x3 matrix). In Bayesian analysis, R is the mean for the prior assigned for the residual variance with degree of freedom df, defaulting to 4.0. If R is not provided, a value is calculated from responses (phenotypes). By default, all effects are treated as fixed and classed as factors (categorical variables) rather than covariates (quantitative variables).","category":"page"},{"location":"manual/workflow/#Step-4:-Set-Factors-or-Covariate","page":"Workflow","title":"Step 4: Set Factors or Covariate","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"set_covariate(model,\"x1\")","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"link to documentation for set_covariate","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"On line 1, the effect x1 is defined to be a covariate (a quantitative variable) rather than a factor (a categorical variable).","category":"page"},{"location":"manual/workflow/#Step-5:-Set-Random-or-Fixed-Effects","page":"Workflow","title":"Step 5: Set Random or Fixed Effects","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"set_random(model,\"x2\",G1) #G1 is optional\nset_random(model,\"ID dam\",pedigree,G2) #G2 is optional","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"link to documentation for set_random","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"On line 1, the x2 class effect is defined as random with variance G1(a 2x2 matrix). On line 2, direct genetic effects and maternal genetic effects are fitted as ID and dam with G2 (a 4x4 matrix) and the inverse of the numerator relationship matrix defined from pedigree. In Bayesian analysis, G1 and G2 are the means for the priors assigned for the variances with degree of freedom df, defaulting to 4.0. If G1 or G2 is not provided, a value is calculated from responses (phenotypes).","category":"page"},{"location":"manual/workflow/#Step-6:-Run-Bayesian-Analysis","page":"Workflow","title":"Step 6: Run Bayesian Analysis","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"outputMCMCsamples(model,\"dam\")\nout=runMCMC(model,phenotypes)","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"link to documentation for outputMCMCsamples\nlink to documentation for runMCMC","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"On line 1, MCMC samples from runMCMC for x2 is saved to a file, where each row represents one sample from the MCMC. On line 2, a multi-trait BayesC analysis is performed with model and phenotypes as had been defined in step 1-6. MCMC samples for marker effects, location parameters specified on line 1, and all variance components from this analysis are saved every output_samples_frequency iterations to files.","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Several steps above can be skipped if no related information is available, e.g., step 4 is skipped if all effects are classed as factors. Several detailed examples are available in the examples section. Here is the link to documentation for all Public functions.","category":"page"},{"location":"manual/workflow/#check-results","page":"Workflow","title":"check results","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Posterior means (estimate) and standard deviations (SD) of location parameters, most variance components, and marker effects are saved as the variable out and in text files. They can be listed and obtained as","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"keys(out)\n\n# output:\n#\n# Base.KeyIterator for a Dict{Any,Any} with 7 entries. Keys:\n#   \"polygenic effects covariance matrix\"\n#   \"Model frequency\"\n#   \"residual covariance matrix\"\n#   \"marker effects\"\n#   \"marker effects variance\"\n#   \"location parameters\"\n#   \"Pi\"\n\nout[\"residual variance\"]\n\n# output:\n#\n#Covariance\tEstimate\tSD\n#y1_y1\t1.65265\t0.29405\n#y1_y2\t-0.0290279\t0.02347\n#y1_y3\t-0.252009\t0.048289\n#y2_y1\t-0.0290279\t0.02347\n#y2_y2\t0.977405\t0.009732\n#y2_y3\t0.0451994\t0.095828\n#y3_y1\t-0.252009\t0.048289\n#y3_y2\t0.0451994\t0.095828\n#y3_y3\t0.363878\t0.049278\n","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"In addition, MCMC samples from posterior distributions of marker effects, all variance components, and location parameters specified in step 7, are saved to text files in your working directory. Users can compute the posterior distributions of parameters of interest using these MCMC samples files. A list of output files are shown below.","category":"page"},{"location":"manual/workflow/#Output-files:","page":"Workflow","title":"Output files:","text":"","category":"section"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Below is a list of files containing estimates and standard deviations for variables of interest. ","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"file name description\nEBV_y1.txt estimated breeding values for trait named \"y1\"\nEBV_y2.txt estimated breeding values for trait named \"y2\"\nEBV_y3.txt estimated breeding values for trait named \"y3\"\ngenetic_variance.txt estimated genetic variance-covariance for all traits\nheritability.txt estimated heritability\nlocation_parameters.txt estimated non-genetic effects\npi_genotypes.txt estimated pi\npolygeniceffectscovariance_matrix.txt estimated variance-covariance between polygenic effects (y1ID, y2ID, y3ID, y1dam)\nmarkereffectsgenotypes.txt estimated marker effects for all traits\nresidual_variance.txt estimated residual variance-covariance for all traits","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"Below is a list of files containing MCMC samples for variables of interest. ","category":"page"},{"location":"manual/workflow/","page":"Workflow","title":"Workflow","text":"file name description\nMCMCsamplesEBV_y1.txt MCMC samples from the posterior distribution of breeding values for trait named \"y1\"\nMCMCsamplesEBV_y2.txt MCMC samples from the posterior distribution of breeding values for trait named \"y2\"\nMCMCsamplesEBV_y3.txt MCMC samples from the posterior distribution of breeding values for trait named \"y3\"\nMCMCsamplesgenetic_variance.txt MCMC samples from the posterior distribution of genetic variance-covariance for all traits\nMCMCsamplesheritability.txt MCMC samples from the posterior distribution of heritability\nMCMCsamplesmarkereffectsgenotypes_y1 MCMC samples from the posterior distribution of marker effects for trait named \"y1\"\nMCMCsamplesmarkereffectsgenotypes_y2 MCMC samples from the posterior distribution of marker effects for trait named \"y2\"\nMCMCsamplesmarkereffectsgenotypes_y3 MCMC samples from the posterior distribution of marker effects for trait named \"y3\"\nMCMCsamplesmarkereffectsvariances_genotypes.txt MCMC samples from the posterior distribution of marker effect variance for all traits\nMCMCsamplespi_genotypes.txt MCMC samples from the posterior distribution of pi\nMCMCsamplespolygeniceffectsvariance.txt MCMC samples from the posterior distribution of variance-covariance between y1ID, y2ID, y3ID, y1dam\nMCMCsamplesresidual_variance.txt MCMC samples from the posterior distribution of residual variance-covariance for all traits\nMCMCsamplesy1.dam.txt MCMC samples from the posterior distribution of dam effect for y1\nMCMCsamplesy1.IDy2.IDy3.IDy1.damvariances.txt MCMC samples from the posterior distribution of variance-covariance between y1ID, y2ID, y3ID, y1dam\nMCMCsamplesy2.x2y3.x2variances.txt MCMC samples from the posterior distribution of variance-covariance between y2x2 and y3x2","category":"page"},{"location":"manual/public/#Public-functions","page":"Public","title":"Public functions","text":"","category":"section"},{"location":"manual/public/","page":"Public","title":"Public","text":"Documentation for JWAS.jl's public interface. Below are functions available to general users.","category":"page"},{"location":"manual/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"manual/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nModules = [JWAS]","category":"page"},{"location":"manual/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"manual/public/","page":"Public","title":"Public","text":"build_model\nget_pedigree\nget_genotypes\nset_covariate\nset_random\nrunMCMC\noutputEBV\noutputMCMCsamples\nshowMME\nsolve","category":"page"},{"location":"manual/public/#JWAS.build_model","page":"Public","title":"JWAS.build_model","text":"build_model(model_equations::AbstractString,R=false; df::AbstractFloat=4.0)\n\nBuild a model from model equations with the residual variance R. In Bayesian analysis, R is the mean for the prior assigned for the residual variance with degree of freedom df, defaulting to 4.0. If R is not provided, a value is calculated from responses (phenotypes).\nBy default, all variabels in modelequations are factors (categorical) and fixed. Set variables to be covariates (continuous) or random using functions `setcovariate()orset_random()`.\n\n#single-trait\nmodel_equations = \"BW = intercept + age + sex\"\nR               = 6.72\nmodels          = build_model(model_equations,R);\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex\n                   CW = intercept + litter\";\nR               = [6.72   24.84\n                   24.84  708.41]\nmodels          = build_model(model_equations,R);\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.PedModule.get_pedigree","page":"Public","title":"JWAS.PedModule.get_pedigree","text":"get_pedigree(pedfile::AbstractString;header=false,separator=',',missingstrings=[\"0\"])\n\nGet pedigree informtion from a pedigree file with header (defaulting to false) , separator (defaulting to ,) and missing values (defaulting to [\"0\"])\nPedigree file format:\n\na,0,0\nc,a,b\nd,a,c\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.get_genotypes","page":"Public","title":"JWAS.get_genotypes","text":"get_genotypes(file::Union{AbstractString,Array{Float64,2},Array{Float32,2},Array{Any,2},DataFrames.DataFrame},G=false;\n              separator=',',header=true,rowID=false,\n              center=true,quality_control=false,\n              method = \"RR-BLUP\",Pi = 0.0,estimatePi = true,estimateScale=false,\n              G_is_marker_variance = false,df = 4.0)\n\nGet marker informtion from a genotype file/matrix. This file needs to be column-wise sorted by marker positions.\nIf a text file is provided, the file format should be:\nAnimal,marker1,marker2,marker3,marker4,marker5\nS1,1,0,1,1,1\nD1,2,0,2,2,1\nO1,1,2,0,1,0\nO3,0,0,2,1,1\nIf an nxp Matrix of genotypes (Array or DataFrame) is provided, where n is the number of individuals and p is the number of markers,\nThis matrix needs to be column-wise sorted by marker positions.\nrowID is a vector of individual IDs, e.g.,rowID=[\"a1\",\"b2\",\"c1\"]; if it is omitted, IDs will be set to 1:n\nheader is a header vector such as [\"id\"; \"mrk1\"; \"mrk2\";...;\"mrkp\"]. If omitted, marker names will be set to 1:p\nIf quality_control=true, defaulting to true,\nMissing genotypes should be denoted as 9, and will be replaced by column means. Users can also impute missing genotypes before the analysis.\nMinor allele frequency MAF threshold, defaulting to 0.01, is uesd, and fixed loci are removed.\nG is the mean for the prior assigned for the genomic variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nAvailable methods include \"conventional (no markers)\", \"RR-BLUP\", \"BayesA\", \"BayesB\", \"BayesC\", \"Bayesian Lasso\", and \"GBLUP\".\nIn Bayesian variable selection methods, Pi for single-trait analyses is a number; Pi for multi-trait analyses is a dictionary such as Pi=Dict([1.0; 1.0]=>0.7,[1.0; 0.0]=>0.1,[0.0; 1.0]=>0.1,[0.0; 0.0]=>0.1), defaulting to all markers have effects (Pi = 0.0) in single-trait analysis and all markers have effects on all traits (Pi=Dict([1.0; 1.0]=>1.0,[0.0; 0.0]=>0.0)) in multi-trait analysis. Pi is estimated if estimatePi = true, , defaulting to false.\nScale parameter for prior of marker effect variance is estimated if estimateScale = true, defaulting to false.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.set_covariate","page":"Public","title":"JWAS.set_covariate","text":"set_covariate(model::MME,variables::AbstractString...)\n\nset variables as covariates; model is the output of function build_model().\n\n#After running build_model, variabels age and year can be set to be covariates as\nset_covariate(model,\"age\",\"year\")\n#or\nset_covariate(model,\"age year\")\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.set_random","page":"Public","title":"JWAS.set_random","text":"set_random(mme::MME,randomStr::AbstractString,ped::Pedigree, G;df=4)\n\nset variables as random polygenic effects with pedigree information ped. and variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\n\n#single-trait (example 1)\nmodel_equation  = \"y = intercept + age + animal\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = 1.6\nset_random(model,\"animal\", ped, G)\n\n#single-trait (example 2)\nmodel_equation  = \"y = intercept + age + animal + animal*age\"\nmodel           = build_model(model_equation,R)\nped             = get_pedigree(pedfile)\nG               = [1.6   0.2\n                   0.2  1.0]\nset_random(model,\"animal animal*age\", ped,G)\n\n#multi-trait\nmodel_equations = \"BW = intercept + age + sex + animal\n                   CW = intercept + age + sex + animal\"\nmodel           = build_model(model_equations,R);\nped             = get_pedigree(pedfile);\nG               = [6.72   2.84\n                   2.84  8.41]\nset_random(model,\"animal\",ped,G)\n\n\n\n\n\nset_random(mme::MME,randomStr::AbstractString,G;Vinv=0,names=[],df=4)\n\nset variables as random effects, defaulting to i.i.d effects, with variances G.\nG is the mean for the prior assigned for the variance with degree of freedom df, defaulting to 4.0. If G is not provided, a value is calculated from responses (phenotypes).\nthe random effects are assumed to be i.i.d by default and it can be defined with any (inverse of) covariance structure Vinv with its index (row names) provided by names.\n\n#single-trait (i.i.d randome effects)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nG               = 0.6\nset_random(model,\"litter\",G)\n\n#multi-trait (i.i.d randome effects)\nmodel_equations = \"BW = intercept + litter + sex\n                   CW = intercept + litter + sex\"\nmodel           = build_model(model_equations,R);\nG               = [3.72  1.84\n                   1.84  3.41]\nset_random(model,\"litter\",G)\n\n#single-trait (randome effects with specific covariance structures)\nmodel_equation  = \"y = intercept + litter + sex\"\nmodel           = build_model(model_equation,R)\nV               = [1.0  0.5 0.25\n                   0.5  1.0 0.5\n                   0.25 0.5 1.0]\nG               = 0.6\nset_random(model,\"litter\",G,Vinv=inv(V),names=[a1;a2;a3])\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.runMCMC","page":"Public","title":"JWAS.runMCMC","text":"runMCMC(model::MME,df::DataFrame;\n        #Data\n        heterogeneous_residuals           = false,\n        #MCMC\n        chain_length::Integer             = 100,\n        starting_value                    = false,\n        burnin::Integer                   = 0,\n        output_samples_frequency::Integer = chain_length>1000 ? div(chain_length,1000) : 1,\n        update_priors_frequency::Integer  = 0,\n        #Methods\n        estimate_variance               = true,\n        single_step_analysis            = false, #parameters for single-step analysis\n        pedigree                        = false, #parameters for single-step analysis\n        fitting_J_vector                = true,  #parameters for single-step analysis\n        categorical_trait               = false,\n        censored_trait                  = false,\n        causal_structure                = false,\n        mega_trait                      = false,\n        missing_phenotypes              = true,\n        constraint                      = false,\n        #Genomic Prediction\n        outputEBV                       = true,\n        output_heritability             = true,\n        prediction_equation             = false,\n        #MISC\n        seed                            = false,\n        printout_model_info             = true,\n        printout_frequency              = chain_length+1,\n        big_memory                      = false,\n        double_precision                = false,\n        ##MCMC samples (defaut to marker effects and hyperparametes (variance components))\n        output_folder                     = \"results\",\n        output_samples_for_all_parameters = false,\n        ##for deprecated JWAS\n        methods                         = \"conventional (no markers)\",\n        Pi                              = 0.0,\n        estimatePi                      = false,\n        estimateScale                   = false)\n\nRun MCMC for Bayesian Linear Mixed Models with or without estimation of variance components.\n\nMarkov chain Monte Carlo\nThe first burnin iterations are discarded at the beginning of a MCMC chain of length chain_length.\nSave MCMC samples every output_samples_frequency iterations, defaulting to chain_length/1000, to a folder output_folder, defaulting to results. MCMC samples for hyperparametes (variance componets) and marker effects are saved by default. MCMC samples for location parametes can be saved using function output_MCMC_samples(). Note that saving MCMC samples too frequently slows down the computation.\nThe starting_value can be provided as a vector for all location parameteres and marker effects, defaulting to 0.0s. The order of starting values for location parameters and marker effects should be the order of location parameters in the Mixed Model Equation for all traits (This can be obtained by getNames(model)) and then markers for all traits (all markers for trait 1 then all markers for trait 2...).\nMiscellaneous Options\nPriors are updated every update_priors_frequency iterations, defaulting to 0.\nMethods\nSingle step analysis is allowed if single_step_analysis = true and pedigree is provided.\nVariance components are estimated if estimate_variance=true, defaulting to true.\nMiscellaneous Options\nMissing phenotypes are allowed in multi-trait analysis with missing_phenotypes=true, defaulting to true.\nCatogorical Traits are allowed if categorical_trait=true, defaulting to false. Phenotypes should be coded as 1,2,3...\nCensored traits are allowed if the upper bounds are provided in censored_trait as an array, and lower bounds are provided as phenotypes.\nIf constraint=true, defaulting to false, constrain residual covariances between traits to be zeros.\nIf causal_structure is provided, e.g., causal_structure = [0.0 0.0 0.0;1.0 0.0 0.0;1.0 0.0 0.0] for trait 1 -> trait 2 and trait 1 -> trait 3 (column index affacts row index, and a lower triangular matrix is required), phenotypic causal networks will be incorporated using structure equation models.\nGenomic Prediction\nPredicted values for individuals of interest can be obtained based on a user-defined prediction equation prediction_equation, e.g., \"y1:animal + y1:age\".\nFor now, genomic data is always included. Genetic values including effects defined with genotype and pedigree information are returned if prediction_equation= false, defaulting to false.\nIndividual estimted genetic values and prediction error variances (PEVs) are returned if outputEBV=true, defaulting to true. Heritability and genetic\nvariances are returned if output_heritability=true, defaulting to true. Note that estimation of heritability is computaionally intensive.\nMiscellaneous Options\nPrint out the model information in REPL if printout_model_info=true; print out the monte carlo mean in REPL with printout_frequency, defaulting to false.\nIf seed, defaulting to false, is provided, a reproducible sequence of numbers will be generated for random number generation.\nIf big_memory=true, defaulting to false, a machine with  lots of memory is assumed which may speed up the analysis.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.outputEBV","page":"Public","title":"JWAS.outputEBV","text":"outputEBV(model,IDs::Array)\n\nOutput estimated breeding values and prediction error variances for IDs.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.outputMCMCsamples","page":"Public","title":"JWAS.outputMCMCsamples","text":"outputMCMCsamples(mme::MME,trmStrs::AbstractString...)\n\nGet MCMC samples for specific location parameters.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/#JWAS.solve","page":"Public","title":"JWAS.solve","text":"solve(mme::MME,df::DataFrame;solver=\"default\",printout_frequency=100,tolerance = 0.000001,maxiter = 5000)\n\nSolve the mixed model equations (no marker information) without estimating variance components.\n\nAvailable solvers include default, Jacobi, Gauss-Seidel, and Gibbs sampler.\n\n\n\n\n\n","category":"function"},{"location":"manual/public/","page":"Public","title":"Public","text":"GWAS","category":"page"},{"location":"manual/public/#JWAS.GWAS","page":"Public","title":"JWAS.GWAS","text":"GWAS(marker_effects_file,model;header=true,window_size=100,threshold=0.001)\n\nrun genomic window-based GWAS without a map file\n\nMCMC samples of marker effects are stored in markereffectsfile with delimiter ','.\nwindow_size is either a constant (identical number of markers in each window) or an array of number of markers in each window\nmodel is either the model::MME used in analysis or the genotypic covariate matrix M::Array\nFile format:\n\n\n\n\n\nGWAS(marker_effects_file;header=true)\n\nCompute the model frequency for each marker (the probability the marker is included in the model) using samples of marker effects stored in markereffectsfile.\n\n\n\n\n\nGWAS(model,map_file,marker_effects_file...;\n     window_size = \"1 Mb\",sliding_window = false,\n     GWAS = true, threshold = 0.001,\n     genetic_correlation = false,\n     header = true)\n\nrun genomic window-based GWAS\n\nMCMC samples of marker effects are stored in markereffectsfile with delimiter ','.\nmodel is either the model::MME used in analysis or the genotype cavariate matrix M::Array\nmap_file has the (sorted) marker position information with delimiter ','. If the map file is not provided, i.e., map_file=false, a fake map file will be generated with window_size markers in each 1 Mb window, and each 1 Mb window will be tested.\nIf two markereffectsfile are provided, and genetic_correlation = true, genomic correlation for each window is calculated.\nStatistics are computed for nonoverlapping windows of size window_size by default. If sliding_window = true, those for overlapping sliding windows are calculated.\nmap file format:\n\nmarkerID,chromosome,position\nm1,1,16977\nm2,1,434311\nm3,1,1025513\nm4,2,70350\nm5,2,101135\n\n\n\n\n\n","category":"function"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#Partial-connected-neural-networks","page":"Part 4. partial connected neural network","title":"Partial-connected neural networks","text":"","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"In partial-connected neural networks, SNPs can be divided into groups by users, and each group connects to its own intermediate trait in the middle layer.  Genotype groups should be loaded seperatly.","category":"page"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#example(c):-partial-connected-neural-networks,-all-intemediate-traits-are-unobserved","page":"Part 4. partial connected neural network","title":"example(c): partial-connected neural networks, all intemediate traits are unobserved","text":"","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"nonlinear function (to define relationship between middle layer and phenotye): tanh\nnumber of nodes in the middle layer: 3\nBayesian model (to sample marker effects on intemediate traits): \ngenotype group 1: single-trait BayesA\ngenotype group 2: single-trait BayesB\ngenotype group 3: single-trait BayesC\nsample the unobserved intemediate traits in the middle layer: Hamiltonian Monte Carlo","category":"page"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"(Image: )","category":"page"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"# Step 1: Load packages\r\nusing JWAS,DataFrames,CSV,Statistics,JWAS.Datasets,Random\r\nRandom.seed!(123)\r\n\r\n# Step 2: Read data\r\nphenofile   = dataset(\"phenotypes.csv\")       \r\ngenofile1   = dataset(\"genotypes_group1.csv\")  #path of genotype group1\r\ngenofile2   = dataset(\"genotypes_group2.csv\")  #path of genotype group2\r\ngenofile3   = dataset(\"genotypes_group3.csv\")  #path of genotype group3\r\n\r\nphenotypes = CSV.read(phenofile,DataFrame,delim = ',',header=true,missingstrings=[\"NA\"])\r\ngeno1  = get_genotypes(genofile1,separator=',',method=\"BayesA\");   #read genotype group1\r\ngeno2  = get_genotypes(genofile2,separator=',',method=\"BayesB\");   #read genotype group2\r\ngeno3  = get_genotypes(genofile3,separator=',',method=\"BayesC\");   #read genotype group3\r\n\r\n# Step 3: Build Model Equations\r\nmodel_equation = \"y1 = intercept + geno1 + geno2 + geno3\";  #middle node1=intercept + geno1\r\n                                                            #middle node2=intercept + geno2\r\n                                                            #middle node3=intercept + geno3\r\nmodel = build_model(model_equation,nonlinear_function=\"tanh\")\r\n\r\n# Step 4: Run Analysis\r\nout = runMCMC(model, phenotypes, chain_length=5000);\r\n\r\n# Step 5: Check Accuruacy\r\nresults    = innerjoin(out[\"EBV_NonLinear\"], phenotypes, on = :ID)\r\naccuruacy  = cor(results[!,:EBV],results[!,:bv1])","category":"page"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/#example(o3):-partial-connected-neural-networks-with-intermediate-omics-data","page":"Part 4. partial connected neural network","title":"example(o3): partial-connected neural networks with intermediate omics data","text":"","category":"section"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"Same as for fully-connected neural network with intermediate omics data, the names of omics features should be put in the build_model() function through the latent_traits argument. The order of omics and the order of genotype groups in the model equation should be consistant.","category":"page"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"In below example, we assume genotype group i only affect omics i (here i =1,...,5).","category":"page"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"(Image: )","category":"page"},{"location":"nnmm/Part4_PartialConnectedNeuralNetwork/","page":"Part 4. partial connected neural network","title":"Part 4. partial connected neural network","text":"# Step 1: Load packages\r\nusing JWAS,DataFrames,CSV,Statistics,JWAS.Datasets,Random,HTTP \r\nRandom.seed!(1)\r\n\r\n# Step 2: Read data\r\nphenofile  = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/y.csv\").body\r\nomicsfile  = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/omics.csv\").body\r\n\r\ngenofile1   = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/geno_group1.csv\").body\r\ngenofile2   = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/geno_group2.csv\").body\r\ngenofile3   = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/geno_group3.csv\").body\r\ngenofile4   = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/geno_group4.csv\").body\r\ngenofile5   = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/geno_group5.csv\").body\r\n\r\nphenotypes  = CSV.read(phenofile,DataFrame)\r\nomics       = CSV.read(omicsfile,DataFrame)[:,1:6] #only use first 5 omics for demonstration\r\nomics_names = names(omics)[2:end] #get names of omics\r\ninsertcols!(omics,2,:y => phenotypes[:,:y], :bv => phenotypes[:,:bv]) #phenotype and omics should be in the same dataframe\r\n\r\ngeno1_df    = CSV.read(genofile1,DataFrame)\r\ngeno2_df    = CSV.read(genofile2,DataFrame)\r\ngeno3_df    = CSV.read(genofile3,DataFrame)\r\ngeno4_df    = CSV.read(genofile4,DataFrame)\r\ngeno5_df    = CSV.read(genofile5,DataFrame)\r\n\r\ngeno1  = get_genotypes(geno1_df,separator=',',method=\"BayesA\");\r\ngeno2  = get_genotypes(geno2_df,separator=',',method=\"BayesB\");\r\ngeno3  = get_genotypes(geno3_df,separator=',',method=\"BayesC\");\r\ngeno4  = get_genotypes(geno4_df,separator=',',method=\"RR-BLUP\");\r\ngeno5  = get_genotypes(geno5_df,separator=',',method=\"BayesL\");\r\n\r\n\r\n# Step 3: Build Model Equations\r\nmodel_equation = \"y = intercept + geno1 + geno2 + geno3 + geno4 + geno5\"; #omics1=intercept+geno1; omics2=intercept+geno2; ...\r\nmodel = build_model(model_equation,\r\n\t\t    num_hidden_nodes=5,\r\n\t\t    nonlinear_function=\"sigmoid\",\r\n\t            latent_traits=omics_names)\r\n\r\n# Step 4: Run Analysis\r\nout = runMCMC(model, omics, chain_length=5000, printout_model_info=false);\r\n\r\n# Step 5: Check Accuruacy\r\nresults    = innerjoin(out[\"EBV_NonLinear\"], omics, on = :ID)\r\naccuruacy  = cor(results[!,:EBV],results[!,:bv])","category":"page"},{"location":"citing/citing/#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing/citing/#Software","page":"Citing","title":"Software","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Cheng, H., Fernando, R. L., and Garrick, D. J. 2018 JWAS: Julia implementation of whole-genome analysis software. Proceedings of the World Congress on Genetics Applied to Livestock Production,11.859. Auckland, New Zealand.","category":"page"},{"location":"citing/citing/#Methods","page":"Citing","title":"Methods","text":"","category":"section"},{"location":"citing/citing/#single-trait-BayesA","page":"Citing","title":"single-trait BayesA","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Meuwissen T, Hayes B, Goddard M. 2001 Prediction of total genetic value using genome-wide dense marker maps. Genetics, 157:1819–1829.","category":"page"},{"location":"citing/citing/#single-trait-BayesB","page":"Citing","title":"single-trait BayesB","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Meuwissen T, Hayes B, Goddard M. 2001 Prediction of total genetic value using genome-wide dense marker maps. Genetics, 157:1819–1829.\nCheng H, Garrick D, Fernando R. 2015 A fast and efficient Gibbs sampler for BayesB in whole-genome analyses. Genet Sel Evol, 47:80.","category":"page"},{"location":"citing/citing/#single-trait-BayesC","page":"Citing","title":"single-trait BayesC","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Habier D, Fernando R, Kizilkaya K, Garrick D. 2011 Extension of the bayesian alphabet for genomic selection. BMC Bioinformatics, 12(1), 186.","category":"page"},{"location":"citing/citing/#single-trait-Bayesian-LASSO","page":"Citing","title":"single-trait Bayesian LASSO","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Gianola, D., & Fernando, R. L. (2019). A Multiple-Trait Bayesian Lasso for Genome-Enabled Analysis and Prediction of Complex Traits. Genetics, 214(2), genetics.302934.2019–331.","category":"page"},{"location":"citing/citing/#multi-trait-Bayesian-Alphabet","page":"Citing","title":"multi-trait Bayesian Alphabet","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Cheng H, Kizilkaya K, Zeng J, Garrick D, Fernando R 2018 Genomic Prediction from Multiple-Trait Bayesian Regression Methods Using Mixture Priors. Genetics, 209(1): 89-103.","category":"page"},{"location":"citing/citing/#single-step-Bayesian-Alphabet","page":"Citing","title":"single-step Bayesian Alphabet","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Fernando R, Dekkers J,Garrick D. 2015 A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses. Genetics Selection Evolution, 46(1), 50.\nFernando, R. L., Cheng, H., Golden, B. L., & Garrick, D. J. (2016). Computational strategies for alternative single-step Bayesian regression models with large numbers of genotyped and non-genotyped animals. Genetics Selection Evolution, 48(1), 96.","category":"page"},{"location":"citing/citing/#GWAS","page":"Citing","title":"GWAS","text":"","category":"section"},{"location":"citing/citing/","page":"Citing","title":"Citing","text":"Fernando R, Garrick D. 2013 Bayesian methods applied to GWAS. Methods Mol Biol., 1019:237–274.\nFernando, R., Toosi, A., Wolc, A., Garrick, D., & Dekkers, J. (2017). Application of Whole-Genome Prediction Methods for Genome-Wide Association Studies: A Bayesian Approach. Journal of Agricultural, Biological and Environmental Statistics, 57(4), 1–22.","category":"page"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#User-defined-relationship-between-middle-layer-(intermediate-traits)-and-output-layer-(phenotype)","page":"Part 5. user-defined onlinear function","title":"User-defined relationship between middle layer (intermediate traits) and output layer (phenotype)","text":"","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/","page":"Part 5. user-defined onlinear function","title":"Part 5. user-defined onlinear function","text":"Firstly, a function should be pre-defined by user, where each function argument represents the input from a intermediate trait. For example, with two omics, we can have pig_growth(omics1,omics2) = sqrt(omics1^2 / (omics1^2 + omics2^2)))\nThen, put the name of the user-define function in the nonlinear_function arugument when build the model.","category":"page"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/#example(b):-user-defined-relationship-between-middle-layer-(intermediate-traits)-and-output-layer-(phenotype)","page":"Part 5. user-defined onlinear function","title":"example(b): user-defined relationship between middle layer (intermediate traits) and output layer (phenotype)","text":"","category":"section"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/","page":"Part 5. user-defined onlinear function","title":"Part 5. user-defined onlinear function","text":"number of nodes in the middle layer: 2\nnonlinear function (to define relationship between middle nodes and phenotype): y = sqrt(x1^2 / (x1^2 + x2^2))\nsample the missing omics in the middle layer: Matropolis-Hastings","category":"page"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/","page":"Part 5. user-defined onlinear function","title":"Part 5. user-defined onlinear function","text":"All the other code are the same as before, except Step 3: Build Model Equations. Note that user-defined relationship is supported in both fully-connected and partial-connected neural network. ","category":"page"},{"location":"nnmm/Part5_UserDefinedNonlinearFunction/","page":"Part 5. user-defined onlinear function","title":"Part 5. user-defined onlinear function","text":"# Step 3: Build Model Equations\r\npig_growth(x1,x2) = sqrt(x1^2 / (x1^2 + x2^2))\r\nmodel = build_model(model_equation,\r\n                    num_hidden_nodes=2,\r\n                    nonlinear_function=pig_growth);","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Mixed-effect-neural-network:-Genotypes-(complete/incomplete)-Intemediate-omics-features-Phenotyes","page":"Part 3. NNMM with intermediate omics","title":"Mixed effect neural network: Genotypes -> (complete/incomplete) Intemediate omics features -> Phenotyes","text":"","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"Tips:","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"Put the names of omics features in the build_model() function through the latent_traits argument.\nIf there are many omics features (e.g., 1000), it is recommanded to set printout_model_info=false in the runMCMC() function.\nMissing omics data for individuals in the training dataset (i.e., individuals with phenotypes) is allowed. When you read a file with missing values via the CSV.read() function, the missingstrings argument should be used to set sentinel values that will be parsed as missing.\nFor individuals in the testing dataset (i.e., individuals without phenotypes), if the testing individuals have complete omics data, then incorporating the omics data of those individuals may improve the relationship between input layer (genotype) and middle layer (omics).","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#example(o1):-fully-connected-neural-networks-with-observed-intemediate-omics-features","page":"Part 3. NNMM with intermediate omics","title":"example(o1): fully-connected neural networks with observed intemediate omics features","text":"","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"nonlinear function (to define relationship between omics and phenotye): sigmoid (other supported activation functions: \"tanh\", \"relu\", \"leakyrelu\", \"linear\")\nnumber of omics features in the middle layer: 10\nBayesian model: multiple independent single-trait BayesC (to sample marker effects on intemediate omics)\nsample the missing omics in the middle layer: Hamiltonian Monte Carlo","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"(Image: )","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"# Step 1: Load packages\r\nusing JWAS,DataFrames,CSV,Statistics,JWAS.Datasets, Random, HTTP #HTTP to download demo data from github\r\nRandom.seed!(123)\r\n\r\n# Step 2: Read data (from github)\r\nphenofile  = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/y.csv\").body\r\nomicsfile  = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/omics.csv\").body\r\ngenofile   = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/geno_n100_p200.csv\").body\r\nphenotypes = CSV.read(phenofile,DataFrame)\r\nomics      = CSV.read(omicsfile,DataFrame)\r\ngeno_df    = CSV.read(genofile,DataFrame)\r\n\r\nomics_names = names(omics)[2:end]  #get names of omics\r\ninsertcols!(omics,2,:y => phenotypes[:,:y], :bv => phenotypes[:,:bv]) #phenotype and omics should be in the same dataframe\r\n\r\ngenotypes = get_genotypes(geno_df,separator=',',method=\"BayesC\")\r\n\r\n# Step 3: Build Model Equations\r\nmodel_equation  =\"y = intercept + genotypes\" #name of phenotypes is \"y\"\r\n                                             #name of genotypes is \"genotypes\" (user-defined in the previous step)\r\n                                             #the single-trait mixed model used between input and each omics is: omics = intercept + genotypes\r\nmodel = build_model(model_equation,\r\n\t\t    num_hidden_nodes=10,          #number of omics in middle layer is 3\r\n                    latent_traits=omics_names,    #name of all omics\r\n\t\t    nonlinear_function=\"sigmoid\") #sigmoid function is used to approximate relationship between omics and phenotypes\r\n\r\n# Step 4: Run Analysis\r\nout=runMCMC(model, omics, chain_length=5000, printout_model_info=false);\r\n\r\n# Step 5: Check Accuruacy\r\nresults    = innerjoin(out[\"EBV_NonLinear\"], omics, on = :ID)\r\naccuruacy  = cor(results[!,:EBV],results[!,:bv])","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Includes-a-residual-that-is-not-mediated-by-other-omics-features","page":"Part 3. NNMM with intermediate omics","title":"Includes a residual that is not mediated by other omics features","text":"","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"To include residuals polygenic component (i.e. directly from genotypes to phenotypes, not mediated by omics features), you can additional hidden nodes in the middle layer (see example (o2)). This can also be achieved in a partial-connected neural network in a same manner.","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"(Image: )","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#example(o2):-fully-connected-neural-network-with-residuals","page":"Part 3. NNMM with intermediate omics","title":"example(o2): fully-connected neural network with residuals","text":"","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"For all individuals, this extra hidden node will be treated as unknown to be sampled.","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"# Step 1: Load packages\r\nusing JWAS,DataFrames,CSV,Statistics,JWAS.Datasets, Random, HTTP \r\nRandom.seed!(123)\r\n\r\n# Step 2: Read data (from github)\r\nphenofile  = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/y.csv\").body\r\nomicsfile  = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/omics.csv\").body\r\ngenofile   = HTTP.get(\"https://raw.githubusercontent.com/zhaotianjing/nnmm_doc/main/data_simulation/geno_n100_p200.csv\").body\r\nphenotypes = CSV.read(phenofile,DataFrame)\r\nomics      = CSV.read(omicsfile,DataFrame)\r\ngeno_df    = CSV.read(genofile,DataFrame)\r\n\r\ninsertcols!(omics, :residual => missing)  #create a hidden node to account for residuals\r\nomics[!,:residual] = convert(Vector{Union{Missing,Float64}}, omics[!,:residual]) #transform the datatype is required for Julia\r\nomics_names = names(omics)[2:end]  #get names of 10 omics and 1 hidden node\r\ninsertcols!(omics,2,:y => phenotypes[:,:y], :bv => phenotypes[:,:bv]) #phenotype and omics should be in the same dataframe\r\n\r\ngenotypes = get_genotypes(geno_df,separator=',',method=\"BayesC\")\r\n\r\n# Step 3: Build Model Equations\r\nmodel_equation  =\"y = intercept + genotypes\" \r\nmodel = build_model(model_equation,\r\n\t\t    num_hidden_nodes=11,   #10 omcis and 1 hidden node\r\n                    latent_traits=omics_names,\r\n\t\t    nonlinear_function=\"sigmoid\")\r\n\r\n# Step 4: Run Analysis\r\nout = runMCMC(model,omics,chain_length=5000,printout_model_info=false)\r\n\r\n# Step 5: Check Accuruacy\r\nresults    = innerjoin(out[\"EBV_NonLinear\"], omics, on = :ID)\r\naccuruacy  = cor(results[!,:EBV],results[!,:bv])","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"Users can also add extra hidden nodes in the partial-connected neural network. Please check next documentation for building a partial-connected neural network.","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Output-files","page":"Part 3. NNMM with intermediate omics","title":"Output files","text":"","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"Same as those described in Part2.","category":"page"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/#Julia-Tips:","page":"Part 3. NNMM with intermediate omics","title":"Julia Tips:","text":"","category":"section"},{"location":"nnmm/Part3_NNMMwithIntermediateOmics/","page":"Part 3. NNMM with intermediate omics","title":"Part 3. NNMM with intermediate omics","text":"You may want to set missing values manually, for example, setting the phenotypes for individuals in testing dataset as missing. Firstly, the type of  columns should be changed to allow missing, e.g., phenotypes[!,:y] =  convert(Vector{Union{Missing,Float64}}, phenotypes[!,:y]). Then, missing can be set manually, e.g., phenotypes[10:11,:y1] .= missing forces the 10th and 11th elements to be missing.","category":"page"},{"location":"FrequentlyAskedQuestions/FrequentlyAskedQuestions/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"FrequentlyAskedQuestions/FrequentlyAskedQuestions/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"link to Frequently Asked Questions wiki ","category":"page"},{"location":"log/","page":"add neural network","title":"add neural network","text":"#allow intermediate omics data in neural networks (8/31/2021)","category":"page"},{"location":"log/","page":"add neural network","title":"add neural network","text":"add an argument \"latenttraits\" in buildmodel() to allow users to provide which columns in the phenotypic data will be used as the observed values for intermediate traits. Add latent_traits as a member in the struct mme.\nBecause multi-trait models with latent traits as responses will be used in neural network (between input layer and hidden layer), we reassign column names of latent traits to mme.lhsVec, which will be used to make the matrices in the multi-trait models. In this case, we still need a variable to save the (empirical) phenotypes (i.e., output), so mme.yobs is made to save it. Add yobs as a member in the struct mme.\nmme.ySparse is used to same values for latent traits. In intermediate omics data, because some/many elements in mme.ySparse are observed, only missing values in mme.ySparse are sampled.","category":"page"},{"location":"log/#add-neural-network","page":"add neural network","title":"add neural network","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: JWAS)","category":"page"},{"location":"","page":"Home","title":"Home","text":"JWAS is a well-documented software platform based on Julia and an interactive Jupyter notebook for analyses of general univariate and multivariate Bayesian mixed effects models.  These models are especially useful for, but not limited to, routine single-trait and multi-trait genomic prediction and genome-wide association studies using either complete or incomplete genomic data (\"single-step\" methods). Currently, JWAS provides broad scope of analyses, e.g., a wide collection of Bayesian methods for whole-genome analyses, including shrinkage estimation and variable selection methods. The features of JWAS include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Univariate (single-trait) analysis\nMultivariate (multi-trait) analysis  \nNo limitations on fixed effects (e.g., herd, year, age, sex)\nRandom effects other than markers (e.g., litter, pen)                                  \nRandom effects using pedigree information\nAdditive genetic effects\nMaternal effects\nRandom permanent environmental effects  \nCorrelated residuals\t\t\nCorrelated random effects\nUnknown (or known) variance components\nUse of genomic information\nComplete genomic data                                      \t\t\nIncomplete genomic data (singe-step)","category":"page"},{"location":"#Supporting-and-Citing","page":"Home","title":"Supporting and Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We hope the friendly user interface and fast computing speed of JWAS will provide power and convenience for users in both industry and academia to analyze large datasets. Further, as a well-documented open-source software tool, we hope JWAS will also be used by a group of active community members, who will contribute to the source code and help maintain the project. Junior scientists can understand and learn the methodologies for whole-genome analyses by using JWAS and reading the tutorials and source code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you would like to help support JWAS, please star the repository on the upper right corner here as such statistic will help to demonstrate the active involvement of the community. If you use JWAS for your research, teaching, or other activities, we would be grateful if you could cite our work following Citing.","category":"page"},{"location":"#The-trouble,-the-error-and-the-new-feature","page":"Home","title":"The trouble, the error and the new feature","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have trouble using JWAS, want new features or find errors in JWAS, please post it in our discussion group, open an issue, or contact <qtlcheng@ucdavis.edu>.","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"theory/theory.md\"\n]\nDepth = 3","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"manual/getstarted.md\",\n  \"manual/workflow.md\",\n  \"manual/public.md\",\n  \"manual/internals.md\",\n]\nDepth = 3","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"examples/examples.md\"\n]\nDepth = 2","category":"page"}]
}
